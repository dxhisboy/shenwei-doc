-
 name: athread_init
 params:
 -
  return int: |
   成功：返回0，表示加速线程初始化成功；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_init()将失败，并返回相应的值：
   -EINVAL：初始化失败。
 cates: [Athread]
 tags: [MPE]
 desc: |
  完成加速线程库的初始化，在使用任何线程库接口前必须调用该接口。
 header: "athread.h"
# inst: test1
# op: |
#  c = a + b
#  return c
-
 name: athread_create
 params:
 -
  int id: 线程绑定ID号
 -
  start_routine fpc: 函数指针
 -
  void* arg: 函数f的参数起始地址
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_create()将失败，并返回相应的值：
   -EAGIAN：超出了系统限制，创建的线程太多。
   -EINVAL：ID号非法(负数，或者超过最大线程数)；或者ID号已经被占用，被占资源没有释放。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  在当前进程中添加新的受控线程。线程执行的起始任务由函数fpc指定；函数fpc的参数由arg提供。
  线程绑定ID号后，线程位置跟ID号无关，如果需要知道线程在核组中所占用的从核资源信息，可以调用相关接口得到该类信息。
-
 name: athread_wait
 params:
 -
  int id: 等待线程id号
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出现了错
   -ESRCH：没有找到指定线程ID对应的线程。
   -EINVAL：ID号非法。
 desc: |
  显式阻塞调用该线程，直到指定的线程终止。指定的线程必须位于当前的进程中。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_end
 params:
 -
  int id: 指定线程ID号
 -
  return int: |
   成功：返回0，线程所占用的从核资源被成功关闭。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_end()将失败，并返回相应的值。
   -ESRCH：没有找到给定线程ID对应的线程。
   -EINVAL：线程从核流水线终止失败，ID对应线程仍然在作业运行中。
 desc: |
  在确定线程所占从核无相关作业后，停滞从核流水线，关闭从核，该从核在本进程中将无法再次使用。
  必须保证从核无任何用户作业才能使用该函数。
 eg: |
  typedef void * (*start_routine)(void *);
  int fun(void * arg){
    retrun (int)arg[0]+(int)arg[1];
  }
  main(){
    int tid1,tid2;
    int arg1[2],arg2[2];
    //线程库初始化
    athread_init();
    //创建绑定线程，线程ID号为0
    arg1[0]=1;
    arg1[1]=2;
    athread_create(0, fun,arg1);
    //创建绑定线程，线程ID号为1
    arg2[0]=3;
    arg2[1]=4;
    athread_create(1, fun,arg2);
    //等待线程结束
    athread_wait(0);
    athread_wait(1);
    //关闭线程所占从核流水线，该从核无法在本进程中继续使用
    athread_end(0);
    athread_end(1);
  }
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn
 params:
 -
  start_routine fpc: 函数指针；
 -
  void* arg: 函数f的参数起始地址。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_spawn()将失败，并返回相应的值。
   -EINVAL：线程组创建失败。
 desc: |
  在当前进程中添加新的受控线程组。线程执行的任务由函数fpc指定；函数fpc的参数由arg提供。
  调用时athread_spawn接口时，启动核组中的所有可用从核资源。如果需要知道线程组在核组中所占用的从核资源信息，可以调用相关接口得到该类信息。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_join
 params:
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出现了错
   -EINVAL：核组内无线程组运行。
 desc: |
  显式阻塞等待该线程组，直到指定的线程组终止。指定的线程组必须位于当前的进程中。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_halt
 desc: |
  在确定线程组所占所有从核无相关作业后，停滞从核组流水线，关闭从核组，该从核组在本进程无法再次使用。
  必须保证从核组无任何用户作业才能使用该函数。
 params:
 -
  return int: |
   成功：返回0，线程所占用的从核资源被成功关闭。
   失败：其它任何返回值都表示出现错误，如果监测到以下任一情况，athread_halt()将失败，并返回相应的值。
   -EINVAL：无法正常关闭从核资源。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn_group
 desc: |
  在当前进程中添加新的带屏蔽码的受控线程组。线程执行的任务由函数fpc指定；函数fpc的参数由arg提供。
  调用时athread_spawn_group接口时，启动屏蔽码中所有从核资源。如果需要知道线程组在核组中所占用的从核资源信息，可以调用相关接口得到该类信息。
 params:
 -
  unsigned long gmask: 从核屏蔽码；
 -
  start_routine fpc: 函数指针；
 -
  void* arg: 函数f的参数起始地址。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_spawn_group()将失败，并返回相应的值。
   -EINVAL：线程组创建失败。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_join_group
 desc: |
  显式阻塞等待带屏蔽码线程组任务结束，直到指定的线程组终止后退出该接口。指定的线程组必须位于当前的进程中。
 params:
 -
  unsigned long gmask: 从核屏蔽码
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出错
   -EINVAL：核组内无线程组运行。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_task
 desc: |
  创建抢占动态调度主核线程。执行的线程任务由函数fpc指定；arg由用户指定线程任务总数，该值表示任务结束的判断标志。
 params:
 -
  start_routine fpc: 函数指针；
 -
  void* arg: 任务总数
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出错
   -EINVAL：线程组创建失败。
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn_task
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  创建抢占动态调度从核线程组。执行的线程任务由函数fpc指定；arg由用户指定线程任务总数，该值表示任务结束的判断标志。
  由于主从核代码对应使用不同的编译器，从核编译的代码不能被主核调用，反之亦然，用户必须保证主核、从核参与的抢占任务有各自对应的代码和编译支撑。
 params:
 -
  start_routine fpc: 函数指针；
 -
  void* arg: 任务总数
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_spawn_task()将失败，并返回相应的值。
   -EINVAL：线程组创建失败。
-
 name: athread_get_max_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  使用该接口得到当前进程的可用的所有核组线程资源总数。
 params:
 -
  return int: |
   成功：返回核组内可用最大线程个数(1<=ret<=64)；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get_max_threads将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
-
 name: athread_set_num_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  使用该接口设置当前进程下一个并行区启动的所有核组线程总数。
 params:
 -
  int num: 线程总数
 -
  return int: |
   成功：0；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_set_num_threads将失败，并返回相应的值。
   -EAGAIN：设置线程数目超过了可用线程资源，将返回该值。
   -EINVAL：并行区线程数设置失败，比如上个并行区任务未完成。
-
 name: athread_get_num_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  使用该接口得到当前进程启动的所有核组线程总数。
 params:
 -
  return int: |
   成功：返回当前核组内线程个数(1<=ret<=64)；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get_num_threads将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
-
 name: athread_cancel
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  该函数用来终止指定线程，线程ID以及资源可以立即收回。
  线程结束可以通过以下方法来终止执行：
  从线程的第一个过程返回，即线程的启动例程。参考athread_create。
  调用athread_cancel，提前退出。
 params:
 -
  int id: 指定退出线程号
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_cancel将失败，并返回相应的值。
   -ESRCH：没有找到指定线程ID对应的线程。
   -EINVAL：ID号非法。
   -EFAULT：ID线程对应从核故障。
-
 name: athread_signal
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  接收中断，并指定中断处理函数。
  参考athread_sigqueue()接口。
 params:
 -
  int signo: 中断信号
 -
  start_routine fpc: 中断处理函数
 -
  return void:
-
 name: Exception_Kind
 params:
 -
  enum UNALIGN: 不对界异常
 -
  enum ILLEGAL:	非法指令
 -
  enum OVI: 整数溢出
 -
  enum INE: 非精确结果
 -
  enum UNF: 下溢
 -
  enum OVF: 上溢
 -
  enum DBZ: 除数为0
 -
  enum INV: 无效操作
 -
  enum DNO: 非规格化数
 -
  enum CLASSE1:	分类计数器溢出
 -
  enum CLASSE2:	分类参数设置异常
 -
  enum SELLDWE:	向量查表异常
 -
  enum LDME: LDM相关异常
 -
  enum SDLBE: SDLB代换时发生越权或越界
 -
  enum MABC: 访问主存的地址超出主存实际配置的容量
 -
  enum MATNO: 主存访问目标核组不在位
 -
  enum RAMAR: 从核收到访存异常错误响应
 -
  enum IFLOWE: 指令流异常
 -
  enum SBMDE1: SBMD匹配异常和SBMD查询异常
 -
  enum SBMDE2: 其他SBMD异常
 -
  enum SYNE1: 从核发出的同步向量中不包含本从核
 -
  enum SYNE2: 可降级同步不使能
 -
  enum RCE: 通信异常
 -
  enum DMAE1: DMA产生DMA描述符静态检查异常
 -
  enum DMAE2: DMA产生DMA描述符静态检查警告
 -
  enum DMAE3: 保留
 -
  enum DMAE4: 行集合模式使用过程中有可能出现访问地址超出LDM容量
 -
  enum DMAE5: 保留
 -
  enum IOE1: 访问保留的IO空间地址
 -
  enum IOE2: IO访问越权
 -
  enum IOE3: IO不可访问
 -
  enum OTHERE: 用户不关心的各类异常
 -
  return enum:
 desc: 可以挂载的异常类型
-
 name: athread_expt_signal
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  挂载特定异常的处理函数。  
  a：异常类型：
    根据申威26011从核异常类型，用户可以挂载Exception_Kind中的32种异常处理信号。
  b：挂载方式
    athread_expt_signal（int exceptnum， void *handler）
  c：异常处理函数
    用户自定义异常处理函数原型为：
    handler_t * handler(int signum, siginfo_t *sinfo, struct sigcontext *sigcontext)
    第一个参数：signum为异常信号
    第二个参数：sinfo的信息如下：
    sinfo->si_signo =signum；	// 异常信号
    sinfo->si_pid = peid;		// 出现异常的从核号
    sinfo->si_uid = cgid;		// 出现异常的核组号
    
    第三个参数：sigcontext的前三个参数用来保留特定信息，如下：
    sigcontext-> sc_onstack			// 从核异常PC是否精确标志
    sigcontext->sc_pc				// 从核异常PC 
    sigcontext-> sc_mask				// 从核数据流异常访存信息
    sc_pc如果为0表示没有异常PC，不为0的情况下根据sc_onstack判断是否为精确PC。
    sc_onstack为0表示没有精确异常pc，此时sc_pc记录的是发生异常时的非精确PC；sc_onstack为1表示有精确异常pc，此时sc_pc记录的是发生异常时的精确PC；
    sc_mask项只对数据流异常DFLOWE有效，为4b`0001表示LD主存，为4b`0010表示ST主存，为4b`0100表示DMA_GET，为4b`1000表示DMA_PUT。
    sigcontext其它各个域的内容由os确定并原样传给用户处理程序。
    发生异常时，线程库会报出第一个捕获的异常，这个异常可以是核组异常也可以是从核异常。如果用户没有挂载相应该异常的处理函数，那么线程库会打印异常相关的所有信息，halt发生异常的从核，并退出程序；如果用户挂载了该异常的处理函数，则进入用户定义的异常处理函数。
    （For 并行C库：athread_expt_signal_for_ccc(void *handler)
    并行C库使用该函数对所有异常事件进行挂载，发生异常时，将会进入并行C库定义的异常函数进行处理，handler函数的参数如下：
    void  handle(int sig, siginfo_t *sinfo, struct sigcontext *sigcontext)
    上述三个参数的内容由操作系统确定并原样传给并行C库异常处理函数
    ）
 params:
 -
  int signo: 异常信号
 -
  start_routine fpc: 异常处理函数
-
 name: IO_addr
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  主核可以通过IO访问局存，该宏返回从核LDM变量element的IO地址。
  IO_addr宏不会判断penum和cgnum的合法性，由用户保证。
 params:
 -
  element: 从核程序内的局存私有变量__thread_local elment，主核使用IO_addr接口前必须加extern __thread声明成外部变量
 -
  penum: 核号
 -
  cgnum: 核组号
 -
  return: 返回IO地址
 eg: |
  从核程序slave.c:
    __thread_local char ch='b';
    __thread_local long para[10] __attribute__((__aligned__(128)))= {0x123, 0x234, 0x345, 0x456};
  主核程序main.c：
    extern long __thread para[];
    extern char __thread ch;
    unsigned long  LDM_addr;
    LDM_addr = IO_addr(para[0], 23，0);
  这样，LDM_addr等于第0号核组第23号从核上para[0]的IO地址
-
 name: h2ldm
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  主核可以通过IO访问局存，该宏直接在主核对从核LDM变量element进行IO存取操作
  h2ldm宏不会判断penum和cgnum的合法性，由用户保证。
 params:
 -
  element: 从核程序内的局存私有变量__thread_local elment，主核使用IO_addr接口前必须加extern __thread声明成外部变量
 -
  penum: 核号
 -
  cgnum: 核组号
 -
  return:
 eg: |
  从核程序slave.c:
    __thread_local char ch='b';
    __thread_local long para[10] __attribute__((__aligned__(128)))= {0x123, 0x234, 0x345, 0x456};
  主核程序main.c：
    extern long __thread para[];
    extern char __thread ch;
    unsigned long  LDM_addr;
    h2ldm(para[0], 23, 0) = 0xaaa;
    h2ldm(ch, 5，1) = 'z';
  主核对0号核组第23号从核上局存变量para[0]赋值；主核对1号核组第5号从核上的局存变量ch赋值。
  备注：
    线程create和spawn接口只带一个参数接口。而主核访问从核局存接口可以用作主核对核组加速区进行批量的参数赋值。比如：从核程序专门申请一块局存空间用作存放参数，主核在启动不同的加速区之前可以对这块参数区进行赋值；如果每个从核上分配相同的参数，通常最优的做法是只对某一个从核进行参数赋值，然后从核通过寄存器通信将参数广播到核组上所有的从核。
-
 name: athread_idle
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  使用该函数可获得当前从核线程组是否处于空闲状态。
  这里的空闲状态是指等待任务的状态，也即：线程组未执行用户spawn的从核加速线程或线程组已经完成用户spawn的从核加速线程。
 params:
 -
  return unsigned long: |
   如果从核组处于空闲状态则返回当前可用的从核位图；否则返回0。
 eg: |
  unsigned long idleslave;
  if(idleslave=athread_idle())
  {
    用从核优化(spawn)；
    ……
  }
-
 name: athread_task_info
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  查询当任务所在CPU中，参与任务执行的核组个数以及当前所在核组的核组号。分别通过查看内部库变量__cgid/__cgnum来得到相应的值。
  调用该接口前，必须先调用athread_task_info来初始化__cgid和__cgnum，通过内部变量来通知参与同步的核组的个数。
  该接口会占有交叉段前64B（0x6000000000~0x6000000000+0x40）的数据作为锁空间，用户在使用该接口时需要注意避开该空间，防止不可预测的错误出现。
-
 name: athread_master_sync
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  核组间同步。
  调用该接口前，必须先调用athread_task_info来初始化__cgid和__cgnum，通过内部变量来通知参与同步的核组的个数。
  该接口会占有交叉段前64B（0x6000000000~0x6000000000+0x40）的数据作为锁空间，用户在使用该接口时需要注意避开该空间，防止不可预测的错误出现。

-
 name: athread_get_id
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  使用该函数获得本地单线程的逻辑标识号(即ID号)。该接口主从核通用。
  只要当线程是被用athread_create创建单线程接口启动的线程才会有绑定的标识符。
 params:
 -
  int core: 指定查询物理核号，-1默认本地从核(从核接口有效)。
 -
  return int: |
   成功：线程逻辑ID号(0<=ret<=63)。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get_id将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
 eg: |
  int myid；
  myid = athread_get_id(-1);
-
 name: athread_get_core
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  使用该接口获得对应线程的物理从核号。该接口主从核通用。
  返回值低6位有效，低3位为列号，高3位为行号，分别表示核组8*8阵列。
 params:
 -
  int id: 指定查询线程号，-1默认本地线程(从核接口有效)。
 -
  return int: |
   成功：线程所占从核物理号(0<=ret<=63)。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get_core将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
 eg: |
  int mycore；
  mycore = athread_get_core(-1);
-
 name: athread_sigqueue
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  从核给主核发送携带消息异步中断，中断发出后，从核并不等待主核是否接收到中断并完成中断处理函数，而是继续执行后续的从核代码。
 params:
 -
  int pid: 主进程，用0表示
 -
  int signo: 中断号
 -
  const union sigval value: 中断消息
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_sigqueue ()将失败，并返回相应的值。
   -EINVAL：signo无效，或者发送消息失败。
 eg: |
  如何正确挂载一个中断处理函数：
  假设主从核约定当从核发出一个SW3_SIGMAX-1的信号的时候，则主核调用中断处理函数x_handler。
  从核程序：
  a=1234567890；
  fun()
  {
    //将中断信号SW3_SIGMAX-1
    //以及中断携带信息&a发给主进程。
    athread_sigqueue(0，SW3_SIGMAX-1，&a)
  }
  主核程序：
    x_handler(int sig, siginfo_t *sinfo, struct sigcontext *sigcontext)
  {
    union sigval sv;
    printf("x_handler begin !\n");
    //sv==从核中断携带信息&a
    sv = sinfo->si_value;
  }
  main()
  {
    athread_signal(SW3_SIGMAX-1，x_handler); //和signal函数用法一致
  }
-
 name: athread_sigsend
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  从核给主核发送携带消息同步中断，中断发出后，从核等待主核接收到中断直到完成中断处理函数后才能继续执行后序从核代码。
 params:
 -
  int pid: 主进程，用0表示
 -
  int signo: 中断号
 -
  const union sigval value: 中断消息
 -
  return int: |
   成功：返回0；
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_sigsend ()将失败，并返回相应的值。
   -EINVAL：signo无效，或者发送消息失败。
 eg: |
  参考athread_sigqueue说明。
-
 name: athread_get
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  从核局存LDM接收主存MEM数据，进行主存MEM到从核LDM的数据get操作，将MEM的数据get到LDM指定位置。传输模式由mode指定，如果是在广播模式和广播行模式下，要进行屏蔽寄存器配置；在其它模式下，mask值无效。

 params:
 -
  dma_mode mode: DMA传输命令模式；
 -
  void* src: DMA传输主存源地址；
 -
  void* dest: DMA传输本地局存目标地址；
 -
  int len: DMA传输数据量，以字节为单位；
 -
  void* reply: DMA传输回答字地址，必须为局存地址，地址4B对界；
 -
  char mask: DMA传输广播有效向量，有效粒度为核组中一行，某位为1表示对应的行传输有效，作用于广播模式和广播行模式；
 -
  int stride: 主存跨步，以字节为单位；
 -
  int bsize: 行集合模式下，必须配置，用于指示在每个从核上的数据粒度大小；其它模式下，在DMA跨步传输时有效，表示DMA传输的跨步向量块大小，以字节为单位。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
 eg: |
  __thread_local long  ldm_a[64];
  __thread long  mem_b[64];
  __thread_local  int reply=0;
  athread_get(PE_MODE,mem_a,ldm_a,64*8,&reply,0,0,0);
  //以单从核模式，从核私有连续段以mem_a为基地址取64*8B数据放入从核局存以ldm_a为基地址的连续64*8B的空间中，其中广播向量、主存跨步、向量块大小均为0。
-
 name: athread_put
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  从核局存LDM往主存MEM发送数据，进行从核LDM到主存MEM的数据put操作，将LDM的数据put到MEM指定的位置。传输模式由mode指定，不支持广播模式和广播行模式。
  DMA传输命令模式参考athread_get接口附加说明。
 params:
 -
  dma_mode mode: DMA传输命令模式；
 -
  void* src: DMA传输局存源地址；
 -
  void* dest: DMA传输主存目的地址；
 -
  int len: DMA传输数据量，以字节为单位；
 -
  void* reply: DMA传输回答字地址，必须为局存地址，地址4B对界；
 -
  int stride: 主存跨步，以字节为单位；
 -
  int bsize: 行集合模式下，必须配置，用于指示在每个从核上的数据粒度大小；其它模式下，在DMA跨步传输时有效，表示DMA传输的跨步向量块大小，以字节为单位。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_put将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
-
 name: athread_get_p
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  物理地址数据接收，除源主存地址为物理地址外，其它使用方式与athread_get一致
 params:
 -
  dma_mode mode: DMA传输命令模式；
 -
  void* src: DMA传输主存源地址；
 -
  void* dest: DMA传输本地局存目标地址；
 -
  int len: DMA传输数据量，以字节为单位；
 -
  void* reply: DMA传输回答字地址，必须为局存地址，地址4B对界；
 -
  char mask: DMA传输广播有效向量，有效粒度为核组中一行，某位为1表示对应的行传输有效，作用于广播模式和广播行模式；
 -
  int stride: 主存跨步，以字节为单位；
 -
  int bsize: 行集合模式下，必须配置，用于指示在每个从核上的数据粒度大小；其它模式下，在DMA跨步传输时有效，表示DMA传输的跨步向量块大小，以字节为单位。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_get将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
-
 name: athread_put_p
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  物理地址数据发送，除目的主存地址为物理地址外，其它使用方式与athread_put一致
 params:
 -
  dma_mode mode: DMA传输命令模式；
 -
  void* src: DMA传输局存源地址；
 -
  void* dest: DMA传输主存目的地址；
 -
  int len: DMA传输数据量，以字节为单位；
 -
  void* reply: DMA传输回答字地址，必须为局存地址，地址4B对界；
 -
  int stride: 主存跨步，以字节为单位；
 -
  int bsize: 行集合模式下，必须配置，用于指示在每个从核上的数据粒度大小；其它模式下，在DMA跨步传输时有效，表示DMA传输的跨步向量块大小，以字节为单位。
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_put将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。

-
 name: athread_dma_barrier
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  发起dma栏栅，对应dma命令操作码为barrier_group
-
 name: scope
 params:
 -
  enum ROW_SCOPE: 行同步，低8位有效
 -
  enum COL_SCOPE: 列同步，低8位有效
 -
  enum ARRAY_SCOPE: 全核组同步，低16位有效，其中16位中低8位为列同步屏蔽码、高8位为行同步屏蔽码
 -
  return enum:
 desc:
  athread_syn的同步域。
-
 name: athread_syn
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  核组内从核同步控制。
 params:
 -
  scope scp: 同步范围控制
 -
  int mask: 同步屏蔽码
 -
  return int: |
   成功：返回0。
   失败：其它任何返回值都表示出现了错，如果监测到以下任一情况，athread_syn将失败，并返回相应的值。
   -EINVAL：返回失败，出现异常。
-
 name: get_allocatable_size
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  得到当前可动态分配的LDM空间大小，也即局存动态分配运行时库管理的LDM空间大小
 params:
 -
  return size_t:
-
 name: ldm_malloc
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  局存空间申请。
 params:
 -
  size_t size: 以字节为单位的空间大小
 -
  return void*: |
   成功返回分配LDM空间的起始地址；
   失败返回NULL；
-
 name: ldm_free
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  局存空间释放，释放空间起始地址为addr。
 params:
 -
  void* addr: 必须是前面某一次ldm_malloc返回的分配成功的局存地址；
 -
  size_t size: 显示指定释放空间的大小，一般必须与前面某一次ldm_malloc的大小相匹配
-
 name: dma_mode
 params:
 -
  enum PE_MODE: 单从核模式
 -
  enum BCAST_MODE: 广播模式
 -
  enum ROW_MODE: 行模式
 -
  enum BROW_MODE: 广播行模式
 -
  enum RANK_MODE: 行集合模式
 -
  return enum:
 desc: 数据DMA中使用的DMA的命令模式。
-
 name: dma_op
 params:
 -
  enum DMA_PUT: 从核向主存存放数据
 -
  enum DMA_GET: 从核从主存获取数据
 -
  enum DMA_PUT_P: 从核向主存存放数据（物理地址）
 -
  enum DMA_GET_P: 从核从主存获取数据（物理地址）
 -
  enum DMA_BARRIER: DMA栏栅
 -
  return enum:
 desc: DMA操作类型。
-
 name: dma_set_size
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  int size:
 -
  return void:
 desc: |
  设置dma描述符的数据传输量属性。
  数据传输量
 eg: |
  dma_set_size(dma_d，256);
-
 name: dma_set_reply
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  int* reply:
 -
  return void:
 desc: |
  设置dma描述符的回答字属性。
 eg: |
  __thread_local reply；
  dma_set_reply(dma_d, &reply);
-
 name: dma_set_op
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  dma_op op:
 -
  return void:
 desc: |
  设置dma描述符的dma操作属性。
 eg: |
  dma_set_op(dma_d, DMA_PUT);
-
 name: dma_set_mode
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  dma_mode mode:
 -
  return void:
 desc: 设置dma描述符的dma模式属性。
 eg: |
  dma_set_op(dma_d, PE_MODE);
-
 name: dma_set_mask
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  int mask:
 -
  return void:
 desc: |
  设置dma描述符的屏蔽码属性。
  只用于广播和广播行模式
 eg: |
  dma_set_mask(dma_d, 1);
-
 name: dma_set_bsize
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  int bsize:
 -
  return void:
 desc: |
  设置dma描述符的跨步向量块大小属性。
  只用于跨步模式以及行集合模式；
  广播模式下的对界（TODO）
  行集合模式下bsize是传输到每个从核上的块大小。
 eg: |
  dma_set_bsize(dma_d, 0x32);
-
 name: dma_set_stepsize
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc* dma_d:
 -
  int length:
 desc: |
  设置dma描述符的主存跨步长度属性。
  只用于跨步模式以及行集合模式；
  广播模式下的对界（TODO）
 eg: |
  dma_set_stepsize(dma_d, 0x128);
-
 name: dma
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc dma_d:
 -
  long mem:
 -
  long ldm:
 inst: dma
 desc: |
  根据参数指定的dma描述符、主存起始地址和局存起始地址，发起dma；
-
 name: dma_wait
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  int* reply:
 -
  int count:
 desc:
   根据参数指定的回答字地址等待，直到回答字的值等于count
-
 name: dma_barrier
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 inst: dma
 desc:
  发起本从核的dma栏栅
-
 name: simd_load
 desc: |
  扩展类型的装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
  装入的内存地址必须32字节对界。
 params:
 -
  intv8 va: 结果存储在va中
 -
  int* addr: 要装入的地址
 cates: [SIMD, SIMD-load, SIMD-int]
 tags: [CPE, MPE]
 header: simd.h
 inst: vldd
-
 name: simd_load
 desc: |
  扩展类型的装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
  装入的内存地址必须32字节对界。
 params:
 -
  doublev4 va: 结果存储在va中
 -
  double* addr: 要装入的地址
 cates: [SIMD, SIMD-load, SIMD-dp]
 tags: [CPE, MPE]
 header: simd.h
 inst: vldd
-
 name: simd_load
 desc: |
  扩展类型的装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
  装入的内存地址必须16字节对界。
 params:
 -
  floatv4 va: 结果存储在va中
 -
  float* addr: 要装入的地址
 cates: [SIMD, SIMD-load, SIMD-sp]
 tags: [CPE, MPE]
 header: simd.h
 inst: vlds
-
 name: simd_loade
 desc: |
  扩展类型的装入并扩展，将8字节（floatv4类型的装入是4字节）长度的数据从连续内存区域中装入到一个向量变量的低64位，并且将该数据扩展到高192位，使向量寄存器的四个寄存器具有相同的值。intv8是取出4字节，然后扩展成8个分量。
 params:
 -
  intv8 va: 结果存储在va中
 -
  int* addr: 要装入的地址
 inst: ldwe
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-int]
-
 name: simd_loade
 desc: |
  扩展类型的装入并扩展，将8字节（floatv4类型的装入是4字节）长度的数据从连续内存区域中装入到一个向量变量的低64位，并且将该数据扩展到高192位，使向量寄存器的四个寄存器具有相同的值。intv8是取出4字节，然后扩展成8个分量。
 params:
 -
  doublev4 va: 结果存储在va中
 -
  double* addr: 要装入的地址
 inst: ldde
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-dp]
-
 name: simd_loade
 desc: |
  扩展类型的装入并扩展，将8字节（floatv4类型的装入是4字节）长度的数据从连续内存区域中装入到一个向量变量的低64位，并且将该数据扩展到高192位，使向量寄存器的四个寄存器具有相同的值。intv8是取出4字节，然后扩展成8个分量。
 params:
 -
  floatv4 va: 结果存储在va中
 -
  float* addr: 要装入的地址
 inst: ldse
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-sp]
-
 name: simd_store
 desc: |
  扩展类型的存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。 
 params:
 -
  intv8 va: 要存储的向量
 -
  int* addr: 存储到的地址
 inst: vstw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-int]
-
 name: simd_store
 desc: |
  扩展类型的存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。 
 params:
 -
  doublev4 va: 要存储的向量
 -
  double* addr: 存储到的地址
 inst: vstd
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-dp]
-
 name: simd_store
 desc: |
  扩展类型的存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。 
 params:
 -
  floatv4 va: 要存储的向量
 -
  float* addr: 存储到的地址
 inst: vsts
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-sp]
-
 name: simd_loadu
 desc: |
  扩展类型的不对界装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
 params:
 -
  intv8 va: 结果存储在va中
 -
  int* addr: 装入的地址
 inst: vldw_ul, vldw_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-int]
-
 name: simd_loadu
 desc: |
  扩展类型的不对界装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
 params:
 -
  doublev4 va: 结果存储在va中
 -
  double* addr: 装入的地址
 inst: vldd_ul, vldd_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-dp]
-
 name: simd_loadu
 desc: |
  扩展类型的不对界装入，将32字节（floatv4类型的装入是16字节）长度的数据从连续内存区域中装入到一个向量变量中。
 params:
 -
  floatv4 va: 结果存储在va中
 -
  float* addr: 装入的地址
 inst: vlds_ul, vlds_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-sp]
-
 name: simd_storeu
 desc: |
  扩展类型的不对界存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。
 params:
 -
  intv8 va: 要存储的向量
 -
  int* addr: 存储到的地址
 inst: vstw_ul, vstw_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-int]
-
 name: simd_storeu
 desc: |
  扩展类型的不对界存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。
 params:
 -
  doublev4 va: 要存储的向量
 -
  double* addr: 存储到的地址
 inst: vstd_ul, vstd_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-dp]
-
 name: simd_storeu
 desc: |
  扩展类型的不对界存储，将一个向量变量中的数据存储到32字节（floatv4类型的装入是16字节）连续内存区域中。
 params:
 -
  floatv4 va: 要存储的向量
 -
  float* addr: 存储到的地址
 inst: vsts_ul, vsts_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-sp]
-
 name: simd_vaddw
 desc: |
  intv8类型的加法，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b相加。可以使用“+”符号替换。
 params:
 -
  intv8 va: 第一个加数
 -
  intv8 vb: 第二个加数
 -
  return intv8: va + vb
 inst: vaddw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsubw
 desc: |
  intv8类型的减法，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b相减。可以使用“-”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va - vb
 inst: vsubw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vandw
 desc: |
  intv8类型的逻辑与，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b进行逻辑与运算。可以使用“&”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va & vb
 inst: vandw/vlogc0
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vbicw
 desc: |
  intv8类型的逻辑与非，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b进行逻辑与非运算。可以使用“&”和“~”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va & ~vb
 inst: vbicw/vlog30
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vbisw
 desc: |
  intv8类型的逻辑或，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b进行逻辑或运算。可以使用“|”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va | vb
 inst: vbisw/vlogfc
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vornotw
 desc: |
  intv8类型的逻辑或非，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b进行逻辑与非运算。可以使用“|”和“~”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va | ~vb
 inst: vlogf3
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vxorw
 desc: |
  intv8类型的逻辑异或，将va中的8个int类型的整型数据分别与vb中的8个int类型的整型数据或8位立即数b进行逻辑异或运算。可以使用“^”符号替换。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va ^ vb
 inst: vxorw/vlog3c
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_veqvw
 desc: |
  intv8类型的逻辑等效，将va中的8个int类型的整型数据和vb中的8个int类型的整型数据或8位立即数b分别对应按位逻辑等效（同或），结果保存到返回值中。
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: ~(va ^ vb)
 inst: veqvw/vlogc3
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsllw
 desc: |
  intv8类型的逻辑左移，将va中的8个int类型的整型数据进行逻辑左移，移出的空位用“0”补充，四个数移位的位数相同，由b中的最低5位或者立即数决定。可以使用“<<”符号替换。
 params:
 -
  intv8 va:
 -
  int b: 
 -
  return intv8: va << b
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = va[i] << b;
  return vc;
 inst: vsllw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsrlw
 desc: |
  intv8类型的逻辑右移，将va中的8个int类型的整型数据进行逻辑右移，移出的空位用“0”补充，四个数移位的位数相同，由b中的最低5位或者5位立即数决定。可以使用“>>”符号替换。使用“>>”符号的时候，如果操作数是有符号的，生成vsraw指令，如果是无符号的，生成vsrlw指令。
 params:
 -
  intv8 va:
 -
  int b: 
 -
  return intv8: va >>> b
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = va[i] >>> b; //vc[i] = ((unsigned int)va[i]) >> b;
  return vc;
 inst: vsrlw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsraw
 desc: |
  intv8类型的算术右移，将va中的8个int类型的整型数据进行逻辑右移，移出的空位用原符号位补充，四个数移位的位数相同，由b中的最低5位或者5位立即数决定。可以使用“>>”符号替换。使用“>>”符号的时候，如果操作数是有符号的，生成vsraw指令，如果是无符号的，生成vsrlw指令。
 params:
 -
  intv8 va:
 -
  int b: 
 -
  return intv8: va >> b
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = va[i] >> b;
  return vc;
 inst: vsraw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vcmpeqw
 header: simd.h
 inst: vcmpeqw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va == vb
 desc: |
  对Va中8个32位的字整数向量元素和Vb中对应8个32位的字整数向量元素（或8位立即数# b）分别进行等于比较运算，若满足指定关系，则Vc中对应的字元素为“1”，否则为“0”。
 op: |
  for (i = 0; i < 8; i ++)
    if ((int)va[i] == (int)vb[i])
      vc[i] = 1;
    else
      vc[i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmplew
 header: simd.h
 inst: vcmplew
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: a <= b
 desc: |
  对Va中8个32位的字整数向量元素和Vb中对应8个32位的字整数向量元素（或8位立即数# b）分别进行小于等于比较运算，若满足指定关系，则Vc中对应的字元素为“1”，否则为“0”。
 op: |
  for (i = 0; i < 8; i ++)
    if ((int)va[i] <= (int)vb[i])
      vc[i] = 1;
    else
      vc[i] = 0;
  return vc;
-
 name: simd_vcmpltw
 header: simd.h
 inst: vcmpltw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va < vb
 desc: |
  对Va中8个32位的字整数向量元素和Vb中对应8个32位的字整数向量元素（或8位立即数# b）分别进行小于比较运算，若满足指定关系，则Vc中对应的字元素为“1”，否则为“0”。
 op: |
  for (i = 0; i < 8; i ++)
    if ((int)va[i] < (int)vb[i])
      vc[i] = 1;
    else
      vc[i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmpulew
 header: simd.h
 inst: vcmpulew
 params:
 -
  uintv8 va:
 -
  uintv8 vb:
 -
  return uintv8: va <= vb
 desc: |
  对Va中8个32位的字整数向量元素和Vb中对应8个32位的字整数向量元素（或8位立即数# b）分别进行无符号小于等于比较运算，若满足指定关系，则Vc中对应的字元素为“1”，否则为“0”。
 op: |
  for (i = 0; i < 8; i ++)
    if ((unsigned int)va[i] <= (unsigned int)vb[i])
      vc[i] = 1;
    else
      vc[i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmpultw
 header: simd.h
 inst: vcmpultw
 params:
 -
  uintv8 va:
 -
  uintv8 vb:
 -
  return uintv8: va < vb
 desc: |
  对Va中8个32位的字整数向量元素和Vb中对应8个32位的字整数向量元素（或8位立即数# b）分别进行无符号小于比较运算，若满足指定关系，则Vc中对应的字元素为“1”，否则为“0”。
 op: |
  for (i = 0; i < 8; i ++)
    if ((unsigned int)va[i] <= (unsigned int)vb[i])
      vc[i] = 1;
    else
      vc[i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vrolw
 header: simd.h
 inst: vrolw
 params:
 -
  intv8 va:
 -
  int b:
 return intv8: (va << b) | (va >>> 32 - b)
 desc: |
  intv8类型的循环左移，将va中的8个int类型的整型数据进行循环左移，移出的空位用移出位补充，四个数移位的位数相同，由b的低5位或5位立即数决定。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = (va[i] << b) | (va[i] >>> (32 - b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_sllow
 header: simd.h
 inst: sllow
 params:
 -
  int256 va:
 -
  int b:
 -
  return int256: va << b
 desc: |
  将Va中256位整体左移，移出的空位用“0”填充，移位位数由b低8位或8位立即数确定，结果写入Vc中。
 op: |
  vc[0] = va[0] << b;
  for (i = 1; i < 8; i ++)
    vc[i] = (va[i] << b) | (va[i - 1] >>> (32 - b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_srlow
 header: simd.h
 inst: srlow
 params:
 -
  int256 va:
 -
  int b:
 -
  return int256: va >> b
 desc: |
  将Va中256位整体右移，移出的空位用“0”填充，移位位数由b低8位或8位立即数确定，结果写入Vc中。
 op: |
  vc[7] = va[7] >> b;
  for (i = 0; i < 7; i ++)
    vc[i] = (va[i] >> b) | (va[i + 1] << (32 - b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vaddl
 header: simd.h
 inst: vaddl
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va + vb
 desc: |
  将Va和Vb中4个64位长字（或8位立即数b）分别对应相加，结果保存到Vc中对应位置。
 op: |
  (by long[4])
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] + vb[i];
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsubl
 header: simd.h
 inst: vsubl
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256 : va - vb
 desc: |
  将Va和Vb中4个64位长字（或8位立即数b）分别对应相减，结果保存到Vc中对应位置。
 op: |
  (by long[4])
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] - vb[i];
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_ctpopow
 header: simd.h
 inst: ctpopow
 params:
 -
  int256 va:
 -
  return int: sum(popcnt(va[i]))
 desc: |
  返回va中的256位八倍字整数中“1”的个数。
 op: |
  int cnt = 0;
  for (i = 0; i < 8; i ++){
    for (j = 0; j < 32; j ++)
      if ((va[i] >> j) & 1)
        cnt ++;
  }
  return cnt;
 tags: [MPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_ctlzow
 header: simd.h
 inst: ctlzow
 params:
 -
  int256 va:
 -
  return int:
 desc: |
  返回Va中的256位八倍字整数从最高位起连续“0”的个数。
 op: |
  int cnt = 0;
  for (i = 7; i >= 0; i --)
    for (j = 31; j >= 0; j --)
      if ((va[i] >> j) & 1)
        cnt ++;
      else
        return cnt;
  return cnt;
 tags: [MPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vucaddw
 header: simd.h
 inst: vucaddw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: 假定va + vb的值被精确表示，max(min(va + vb, 2147483647), -2147483648)
 desc: |
  将Va和Vb中对应的8个32位字整数（或8位立即数#b零扩展的字整数）分别进行32位的有符号加，取低32位结果保存到Vc。若结果产生上溢，则将对应的32位结果置为0x7fff,ffff；若产生下溢，则将对应的32位结果置为0x8000,0000。
 op: |
  for (i = 0; i < 8; i ++){
    long tmp = (long)va[i] + (long)vb[i];
    if (tmp > 0x000000007fffffffLL)
      tmp = 0x000000007fffffff;
    if (tmp < 0xffffffff80000000LL)
      tmp = 0xffffffff80000000;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubw
 header: simd.h
 inst: vucsubw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: 假定va - vb的值被精确表示，max(min(va - vb, 2147483647), -2147483648)
 desc: |
  将Va和Vb中对应的8个32位字整数（或8位立即数#b零扩展的字整数）分别进行32位的有符号减，取低32位结果保存到Vc。若结果产生上溢，则将对应的32位结果置为0x7fff,ffff；若产生下溢，则将对应的32位结果置为0x8000,0000。
 op: | 
  for (i = 0; i < 8; i ++){
    long tmp = (long)va[i] - (long)vb[i];
    if (tmp > 0x000000007fffffffLL)
      tmp = 0x000000007fffffff;
    if (tmp < 0xffffffff80000000LL)
      tmp = 0xffffffff80000000;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucaddh
 header: simd.h
 inst: vucaddh
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: 假定va + vb的值被精确表示，max(min(va + vb, 65535), -65536)
 desc: |
  将Va和Vb中对应的16个16位半字整数（或8位立即数#b零扩展的半字整数）分别进行16位的有符号加，取低16位结果保存到Vc。若结果产生上溢，则将对应的16位结果置为0x7fff；若产生下溢，则将对应的16位结果置为0x8000。
 op: |
  (by short[16])
  for (i = 0; i < 16; i ++){
    int tmp = (int)va[i] + (int)vb[i];
    if (tmp > 0x00007fff)
      tmp = 0x00007fff;
    if (tmp < 0xffff8000)
      tmp = 0xffff8000;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubh
 header: simd.h
 inst: vucsubh
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: 假定va - vb的值被精确表示，max(min(va - vb, 65535), -65536)
 desc: |
  将Va和Vb中对应的16个16位半字整数（或8位立即数#b零扩展的半字整数）分别进行16位的有符号减，取低16位结果保存到Vc。若结果产生上溢，则将对应的16位结果置为0x7fff；若产生下溢，则将对应的16位结果置为0x8000。
 op: |
  (by short[16])
  for (i = 0; i < 16; i ++){
    int tmp = (int)va[i] - (int)vb[i];
    if (tmp > 0x00007fff)
      tmp = 0x00007fff;
    if (tmp < 0xffff8000)
      tmp = 0xffff8000;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucaddb
 header: simd.h
 inst: vucaddb
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: 假定va + vb的值被精确表示，max(min(va + vb, 255), -256)
 desc: |
  将Va和Vb中对应的32个8位字节整数（或8位立即数#b）分别进行8位的有符号加，取低8位结果保存到Vc。若结果产生上溢，则将对应的8位结果置为0x7f；若产生下溢，则将对应的8位结果置为0x80。
 op: |
  (by char[32])
  for (i = 0; i < 32; i ++){
    int tmp = (short)va[i] + (short)vb[i];
    if (tmp > 0x007f)
      tmp = 0x007f;
    if (tmp < 0xff80)
      tmp = 0xff80;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubb
 header: simd.h
 inst: vucsubb
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8:  假定va - vb的值被精确表示，max(min(va - vb, 255), -256)
 desc: |
  将Va和Vb中对应的32个8位字节整数（或8位立即数#b）分别进行8位的有符号减，取低8位结果保存到Vc。若结果产生上溢，则将对应的8位结果置为0x7f；若产生下溢，则将对应的8位结果置为0x80。
 op: |
  (by char[32])
  for (i = 0; i < 32; i ++){
    int tmp = (int)va[i] - (int)vb[i];
    if (tmp > 0x007f)
      tmp = 0x007f;
    if (tmp < 0xff80)
      tmp = 0xff80;
    vc[i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vseleqw
 header: simd.h
 inst: vseleqw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va == 0 ? vb : vc
 desc: |
  对Va中每个字元素与0进行等于比较测试，若条件成立，则将向量Vb对应的字元素写入Vd的对应位置，否则将向量Vc对应的字元素（或“0”扩展5位立即数#c形成的字整数）写入Vd的对应位置。
 op: |
  for (i = 0; i < 8; i ++){
    vc[i] = va[i] == 0 ? vb[i] : vc[i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsellew
 header: simd.h
 inst: vsellew
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va <= 0 ? vb : vc
 desc: |
  对Va中每个字元素与0进行小于等于比较测试，若条件成立，则将向量Vb对应的字元素写入Vd的对应位置，否则将向量Vc对应的字元素（或“0”扩展5位立即数#c形成的字整数）写入Vd的对应位置。
 op: |
  for (i = 0; i < 8; i ++){
    vc[i] = va[i] <= 0 ? vb[i] : vc[i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vselltw
 header: simd.h
 inst: vselltw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va < 0 ? vb : vc
 desc: |
  对Va中每个字元素与0进行小于比较测试，若条件成立，则将向量Vb对应的字元素写入Vd的对应位置，否则将向量Vc对应的字元素（或“0”扩展5位立即数#c形成的字整数）写入Vd的对应位置。
 op: |
  for (i = 0; i < 8; i ++){
    vc[i] = va[i] <= 0 ? vb[i] : vc[i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]

-
 name: simd_vsellbcw
 header: simd.h
 inst: vsellbcw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   (va & 1) == 0 ? vb : vc
 desc: |
  对Va中每个字元素的低位进行测试，若为0，则将向量Vb对应的字元素写入Vd的对应位置，否则将向量Vc对应的字元素（或“0”扩展5位立即数#c形成的字整数）写入Vd的对应位置。
 op: |
  for (i = 0; i < 8; i ++){
    vc[i] = (va[i] & 1) == 0 ? vb[i] : vc[i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vlog
 header: simd.h
 inst: vlogzz
 params:
 -
  lit8 zz:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: zz[(va << 2) + (vb << 1) + vc]
 desc: |
  将Va、Vb和Vc中对应的每一位，组成3位的二进制数，从两位16进制参数zz的8位二进制值中选出一位，写入Vd的对应位中。
 op: |
  int truth[8];
  for (i = 0; i < 8; i ++)
    truth[i] = (zz >> i) & 1;
  for (i = 0; i < 8; i ++){
    vc[i] = 0;
    for (j = 0; j < 32; j ++){
      a = (va[i] >> j) & 1;
      b = (vb[i] >> j) & 1;
      c = (vc[i] >> j) & 1;
      vc[i] = truth[(a << 2) + (b << 1) + c];
    }
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vaddd
 inst: vaddd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va + vb
 desc: |
  doublev4类型的加法运算，将va中的4个double浮点数分别与vb中的4个double浮点数进行加法运算。可以用“+”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] + vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vadds
 inst: vadds
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va + vb
 desc: |
  floatv4类型的加法运算，将va中的4个float浮点数分别与vb中的4个float浮点数进行加法运算。可以用“+”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] + vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsubd
 inst: vsubd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va - vb
 desc: |
  doublev4类型的减法运算，将va中的4个double浮点数分别与vb中的4个double浮点数进行减法运算。可以用“-”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] - vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsubs
 inst: vsubs
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va - vb
 desc: |
  floatv4类型的减法运算，将va中的4个float浮点数分别与vb中的4个float浮点数进行减法运算。可以用“-”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
   vc[i] = va[i] - vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmuld
 inst: vmuld
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va * vb
 desc: |
  doublev4类型的乘法运算，将va中的4个double浮点数分别与vb中的4个double浮点数进行乘法运算。可以用“*”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] * vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmuls
 inst: vmuls
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va * vb
 desc: |
  floatv4类型的乘法运算，将va中的4个float浮点数分别与vb中的4个float浮点数进行乘法运算。可以用“*”符号替换。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] * vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmad
 inst: vmad
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: va * vb + vc
 desc: |
  doublev4类型的乘加运算，将va中的4个double浮点数和vb中的4个double浮点数以及vc中的4个浮点数分别进行乘加运算。可以用“*”和“+”符号替换。
  ret = va*vb + vc;
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] * vb[i] + vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmas
 inst: vmas
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4:
 desc: |
  floatv4类型的乘加运算，将va中的4个float浮点数和vb中的4个float浮点数以及vc中的4个浮点数分别进行乘加运算。可以用“*”和“+”符号替换。
  ret = va*vb + vc;
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] * vb[i] + vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmsd
 inst: vfmsd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: va * vb - vc
 desc: |
  doublev4类型的乘减运算，将va中的4个double浮点数和vb中的4个double浮点数以及vc中的4个浮点数分别进行乘减运算。可以用“*”和“-”符号替换。
  ret=va*vb-vc；
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] * vb[i] - vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmss
 inst: vmss
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: va * vb - vc
 desc: |
  floatv4类型的乘减运算，将va中的4个浮点数和vb中的4个浮点数以及vc中的4个浮点数分别进行乘减运算。可以用“*”和“-”符号替换。
  ret=va*vb-vc;
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] * vb[i] - vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vnmad
 inst: vnmad
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: -va * vb + vc
 desc: |
  doublev4类型的负乘加运算，将va中的4个double浮点数和vb中的4个double浮点数以及vc中的4个浮点数分别进行负乘加运算。可以用“*”和“+”和“-”符号替换。
  ret = -va*vb + vc；
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = -va[i] * vb[i] + vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vnmas
 inst: vnmas
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: -va * vb +vc
 desc: |
  floatv4类型的负乘加运算，将va中的4个float浮点数和vb中的4个float浮点数以及vc中的4个浮点数分别进行负乘加运算。可以用“*”和“+”和“-”符号替换。
  ret = -va*vb + vc；
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = -va[i] * vb[i] + vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vnmsd
 inst: vnmsd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: -va * vb - vc
 desc: |
  doublev4类型的负乘减运算，将va中的4个double浮点数和vb中的4个double浮点数以及vc中的4个浮点数分别进行负乘减运算。可以用“*”和“+”和“-”符号替换。
  ret = -va*vb - vc；
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = -va[i] * vb[i] - vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vnmss
 inst: vnmss
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4:
 desc: |
  floatv4类型的负乘减运算，将va中的4个float浮点数和vb中的4个float浮点数以及vc中的4个浮点数分别进行负乘减运算。可以用“*”和“+”和“-”符号替换。
  ret = -va*vb - vc；
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = -va[i] * vb[i] - vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vseleq
 inst: vseleq
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va == 0 ? vb : vc
 desc: |
  判断doublev4/floatv4类型的参数va，如果等于0，则返回vb的值；否则返回vc的值。
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] == 0 ? vb[i] : vc[i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vseleq
 inst: vseleq
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va == 0 ? vb : vc
 desc: |
  判断doublev4/floatv4类型的参数va，如果等于0，则返回vb的值；否则返回vc的值。
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] == 0 ? vb[i] : vc[i];
  return vd;  
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsellt
 inst: vsellt
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va < 0 ? vb : vc
 desc: |
  判断doublev4/floatv4类型的参数va，如果小于0，则返回vb的值；否则返回vc的值。
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] < 0 ? vb[i] : vc[i];
  return vd;  
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsellt
 inst: vsellt
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va < 0 ? vb : vc
 desc: |
  判断doublev4/floatv4类型的参数va，如果小于0，则返回vb的值；否则返回vc的值。
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] < 0 ? vb[i] : vc[i];
  return vd;  
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vselle
 inst: vselle
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va <= 0 ? vb : vc
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] <= 0 ? vb[i] : vc[i];
  return vd;
 desc: |
  判断doublev4/floatv4类型的参数va，如果小于等于0，则返回vb的值；否则返回vc的值。
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vselle
 inst: vselle
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va <= 0 ? vb : vc
 desc: |
  判断doublev4/floatv4类型的参数va，如果小于等于0，则返回vb的值；否则返回vc的值。
 op: |
  for (i = 0; i < 4; i ++)
    vd[i] = va[i] <= 0 ? vb[i] : vc[i];
  return vd;  
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpys
 inst: vcpys
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   (va & 8000 0000) | (vb & 0x7fff ffff)
 desc: |
  浮点拷贝符号，返回值中的符号位是va的符号位，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = (va[i] & 80000000) | (vb[i] & 0x7fffffff);
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpys
 inst: vcpys
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   (va & 8000 0000 0000 0000) | (vb & 0x7fff ffff ffff ffff)
 desc: |
  浮点拷贝符号，返回值中的符号位是va的符号位，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = (va[i] & 8000000000000000LL) | (vb[i] & 0x7fffffffffffffffLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vcpyse
 inst: vcpyse
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: (va & 0xff80 0000) | (vb & 0x007f ffff)
 desc: |
  浮点拷贝符号和指数，返回值中的符号位和指数位是va的数据，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = (va[i] & 0xff800000) | (vb[i] & 0x007fffff);
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpyse
 inst: vcpyse
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   (va & 0xfff0 0000 0000 0000) | (vb & 0x000f ffff ffff ffff)
 desc: |
  浮点拷贝符号和指数，返回值中的符号位和指数位是va的数据，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = (va[i] & 0xfff0000000000000LL) | (vb[i] & 0x000fffffffffffffLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vcpysn
 inst: vcpysn
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   ((~va) & 0x8000 0000) | (vb & 0x7fff ffff)
 desc: |
  浮点拷贝符号反码，返回值中的符号位是va的符号位的反码，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = ((~va) & 0x80000000) | (vb &0x7fffffff)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpysn
 inst: vcpysn
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   ((~va) & 0x8000 0000 0000 0000) | (vb & 0x7fff ffff ffff ffff)
 desc: |
  浮点拷贝符号反码，返回值中的符号位是va的符号位的反码，其余部分为vb中的数据。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = ((~va[i]) & 0x8000000000000000LL) | (vb[i] & 0x7fffffffffffffffLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vdivd
 inst: vdivd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va / vb
 desc: |
  doublev4类型的除法运算，将va中的4个double浮点数分别与vb中的4个double浮点数进行除法运算。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] / vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vdivs
 inst: vdivs
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va / vb
 desc: |
  floatv4类型的乘法运算，将va中的4个float浮点数分别与vb中的4个float浮点数进行除法运算。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] / vb[i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsqrtd
 inst: vsqrtd
 params:
 -
  doublev4 va:
 -
  return doublev4: sqrt(va)
 desc: |
  doublev4类型的求平方根运算，将va中的4个double浮点数分别求平方根。
 op: |
  for (i = 0; i < 4; i ++)
    vb[i] = sqrt(va[i]);
  return vb;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsqrts
 inst: vsqrts
 params:
 -
  floatv4 va:
 -
  return floatv4: sqrt(va)
 desc: |
  floatv4类型的求平方根运算，将va中的4个float浮点数分别求平方根。
 op: |
  for (i = 0; i < 4; i ++)
    vb[i] = sqrt(va[i]);
  return vb;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmpeq
 inst: vfcmpeq
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va == vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行等于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] == vb[i] ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmpeq
 inst: vfcmpeq
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va == vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行等于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] == vb[i] ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmple
 inst: vfcmple
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va <= vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行小于等于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] <= vb[i] ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmple
 inst: vfcmple
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va <= vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行小于等于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmplt
 inst: vfcmplt
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va < vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行小于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] < vb[i] ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmplt
 inst: vfcmplt
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va < vb ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行小于比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = va[i] < vb[i] ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmpun
 inst: vfcmpun
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   isnan(va) || isnan(vb) ? 2.0 : 0
 desc: |
  将Va和Vb中的对应浮点向量元素进行无序比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = isnan(va[i]) || isnan(vb[i]) ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmpun
 inst: vfcmpun
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   isnan(va) || isnan(vb) ? 2.0 : 0;
 desc: |
  将Va和Vb中的对应浮点向量元素进行无序比较，如果条件成立，则将非“0”浮点值（2.0）写入vc的对应位置，否则将真“0”写入vc的对应位置。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = isnan(va[i]) || isnan(vb[i]) ? 2.0 : 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vinswn
 inst: vinsw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: |
   vb[0 : n]va[0]vb[n + 1 : 8]
 desc: |
  将浮点寄存器va低64位的寄存器格式字整数转换为32位字整数，替代vb中由n（有效值为0～7）指定32位字元素，组成并返回新的字整数向量。
  该接口实际上对应8个接口，分别是simd_vinsw0、simd_vinsw1、simd_vinsw2、simd_vinsw3、simd_vinsw4、simd_vinsw5、simd_vinsw6、simd_vinsw7，比如：
  vc=simd_vinsw2
  表示va低64位的寄存器格式字整数先转换为32位字整数，然后替代vb的64：95这32位的字元素，组成新的vb返回给vc。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = vb[i];
  vc[n] = va[n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vinsfn
 inst: vinsf
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   vb[0 : n]va[0]vb[n + 1 : 8]
 desc: |
  将浮点寄存器va低64位浮点数据替代vb中由n（有效值为0～3）指定的64位浮点元素，组成并返回新的浮点向量。
  该接口实际上对应4个接口，分别是simd_vinsf0、simd_vinsf1、simd_vinsf2、simd_vinsf3，比如：
  vc=simd_vinsf1(va,vb)
  表示va低64位浮点数据替代vb的64：127这64位的浮点元素，组成新的vb返回给vc。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = vb[i];
  vc[n] = va[n];

 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vinsfn
 inst: vinsf
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   vb[0 : n]va[0]vb[n + 1 : 8]
 desc: |
  将浮点寄存器va低64位浮点数据替代vb中由n（有效值为0～3）指定的64位浮点元素，组成并返回新的浮点向量。
  该接口实际上对应4个接口，分别是simd_vinsf0、simd_vinsf1、simd_vinsf2、simd_vinsf3，比如：
  vc=simd_vinsf1(va,vb)
  表示va低64位浮点数据替代vb的64：127这64位的浮点元素，组成新的vb返回给vc。
 op: |
  for (i = 0; i < 4; i ++)
    vc[i] = vb[i];
  vc[n] = va[n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_vextwn
 inst: vextw
 params:
 -
  intv8 va:
 -
  return intv8: va[n]
 desc: |
  将va中由n（有效值为0～7）指定的32位字元素，变为64位寄存器格式的字整数写入目的浮点寄存器的低64位，目的寄存器的高192位内容不确定。
  该接口实际上对应8个接口，分别是simd_vextw0、simd_vextw1、simd_vextw2、simd_vextw3、simd_vextw4、simd_vextw5、simd_vextw6、simd_vextw7，比如：
  vc=simd_vextw2(va)
  表示va的 64：95这32位的字元素，变为64位寄存器格式的字整数写入vc低64位，其中vc高192位内容不确定。
 op: return va[n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vextfn
 inst: vextf
 params:
 -
  doublev4 va:
 -
  return doublev4: va[n]
 desc: |
  将va中由n（有效值为0～3）指定的S浮点或D浮点元素存入目的寄存器的<63:0>中。此指令可实现S浮点和D浮点的提取。
  该接口实际上对应4个接口，分别是simd_vextf0、simd_vextf1、simd_vextf2、simd_vextf3，比如：
  vc=simd_vextf1(va)
  表示va的 64：127这64位的浮点元素存入vc的<63:0>中。
 op: return va[n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vextfn
 inst: vextf
 params:
 -
  floatv4 va:
 -
  return floatv4: va[n]
 desc: |
  将va中由n（有效值为0～3）指定的S浮点或D浮点元素存入目的寄存器的<63:0>中。此指令可实现S浮点和D浮点的提取。
  该接口实际上对应4个接口，分别是simd_vextf0、simd_vextf1、simd_vextf2、simd_vextf3，比如：
  vc=simd_vextf1(va)
  表示va的 64：127这64位的浮点元素存入vc的<63:0>中。
 op: return va[n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_vcpyw
 inst: vcpyw
 params:
 -
  doublev4 va:
 -
  return intv8: |
   *(int*)&va[0];
 desc: |
  将va低64位的寄存器格式字整数转换位32位字整数，复制成8个相同元素组成新的字整数向量写入目的寄存器。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = *(int*)&va[0];;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int, SIMD-sp]
-
 name: simd_vcpyw
 inst: vcpyw
 params:
 -
  floatv4 va:
 -
  return intv8: |
   *(int*)&va[0];
 desc: |
  将va低64位的寄存器格式字整数转换位32位字整数，复制成8个相同元素组成新的字整数向量写入目的寄存器。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = *(int*)&va[0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int, SIMD-sp]
-
 name: simd_vcpyf
 inst: vcpyf
 params:
 -
  doublev4 va:
 -
  return doublev4: va[0]
 desc: |
  将va低64位浮点数据，复制成4个相同元素，组成新的浮点向量写入目的寄存器。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = va[0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vcpyf
 inst: vcpyf
 params:
 -
  floatv4 va:
 -
  return floatv4: va[0]
 desc: |
  将va低64位浮点数据，复制成4个相同元素，组成新的浮点向量写入目的寄存器。
 op: |
  for (i = 0; i < 8; i ++)
    vc[i] = va[0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_set_doublev4
 params:
 -
  double a:
 -
  double b:
 -
  double c:
 -
  double d:
 -
  return doublev4: |
   [a, b, c, d]
 desc: |
  doublev4类型的赋值函数，将4个double类型的数据传递到向量变量中。
 eg: |
  doublev4 va=simd_set_doublev4(1.0，2.0，3.0，4.0);
  va中的值是这样的：
    +-----+-----+-----+-----+
    | 4.0 | 3.0 | 2.0 | 1.0 |
    +-----+-----+-----+-----+
  255                       0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-dp]
-
 name: simd_set_floatv4
 params:
 -
  float a:
 -
  float b:
 -
  float c:
 -
  float d:
 -
  return floatv4: |
   [a, b, c, d]
 desc: |
  floatv4类型的赋值函数，将4个float类型的数据传递到向量变量中。
 eg: |
  floatv4 va=simd_set_floatv4(1.0，2.0，3.0，4.0);
  va中的值是这样的：
    +-----+-----+-----+-----+
    | 4.0 | 3.0 | 2.0 | 1.0 |
    +-----+-----+-----+-----+
  255                       0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-sp]
-
 name: simd_set_intv8
 params:
 -
  int a:
 -
  int b:
 -
  int c:
 -
  int d:
 -
  int e:
 -
  int f:
 -
  int g:
 -
  int h:
 -
  return intv8: |
   [a, b, c, d, e, f, g, h]
 desc: |
  intv8类型的赋值函数，将8个int类型的数据传递到向量变量中。
 eg: |
  va=simd_set_intv8(1,2,3,4,5,6,7,8);
  va中的值是这样的：
    +---+---+---+---+---+---+---+---+
    | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
    +---+---+---+---+---+---+---+---+
  255                               0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_uintv8
 params:
 -
  unsigned int a:
 -
  unsigned int b:
 -
  unsigned int c:
 -
  unsigned int d:
 -
  unsigned int e:
 -
  unsigned int f:
 -
  unsigned int g:
 -
  unsigned int h:
 -
  return uintv8: |
   [a, b, c, d, e, f, g, h]
 desc: |
  uintv8类型的赋值函数，将8个unsigned int类型的数据传递到向量变量中。
 eg: |
  va=simd_set_uintv8(1,2,3,4,5,6,7,8);
  va中的值是这样的：
    +---+---+---+---+---+---+---+---+
    | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
    +---+---+---+---+---+---+---+---+
  255                               0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_int256
 params:
 -
  long a:
 -
  long b:
 -
  long c:
 -
  long d:
 -
  return int256: |
   [a, b, c, d]
 desc: |
  int256类型的赋值函数，将4个long类型的数据传递到向量变量中。
 eg: |
  va=simd_set_int256(1,2,3,4);
  va中的值是这样的：
    +---+---+---+---+
    | 4 | 3 | 2 | 1 |
    +---+---+---+---+
  255               0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_uint256
 params:
 -
  unsigned long a:
 -
  unsigned long b:
 -
  unsigned long c:
 -
  unsigned long d:
 -
  return uint256: |
   [a, b, c, d]
 desc: |
  uint256类型的赋值函数，将4个unsigned long类型的数据传递到向量变量中。
 eg: |
  va=simd_set_uint256(1,2,3,4);
  va中的值是这样的：
    +---+---+---+---+
    | 4 | 3 | 2 | 1 |
    +---+---+---+---+
  255               0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_fprint_intv8
 params:
 -
  FILE *file:
 -
  intv8 va:
 desc: |
  intv8类型的数据以8个int的形式打印到文件file中。
 eg: |
  va=simd_set_intv8(1,2,3,4,5,6,7,8);
  simd_fprint_intv8(stderr, va);
  打印的结果是这样的：
  [8，7，6，5，4, 3, 2, 1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-int]
-
 name: simd_fprint_uintv8
 params:
 -
  FILE *file:
 -
  uintv8 va:
 desc: |
  uintv8类型的数据以8个int的形式打印到文件file中。
 eg: |
  va=simd_set_uintv8(1,2,3,4,5,6,7,8);
  simd_fprint_uintv8(stderr, va);
  打印的结果是这样的：
  [8，7，6，5，4, 3, 2, 1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_int256
 params:
 -
  FILE *file:
 -
  int256 va:
 desc: |
  int256类型的数据以4个long的形式打印到文件file中。
 eg: |
  va=simd_set_int256(1,2,3,4);
  simd_fprint_int256(stderr, va);
  打印的结果是这样的：
  [ 0x4, 0x3, 0x2, 0x1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_uint256
 params:
 -
  FILE *file:
 -
  uint256 va:
 desc: |
  uint256类型的数据以4个long的形式打印到文件file中。
 eg: |
  va=simd_set_uint256(1,2,3,4);
  simd_fprint_uint256(stderr, va);
  打印的结果是这样的：
  [ 0x4, 0x3, 0x2, 0x1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_floatv4
 params:
 -
  FILE *file:
 -
  floatv4 va:
 desc: |
  floatv4类型的数据以4个float的形式打印到文件file中。
 eg: |
  va=simd_set_floatv4(1.0,2.0,3.0,4.0);
  simd_fprint_floatv4(stderr, va);
  打印的结果是这样的：
  [ 3.0，4.0，2.0, 1.0 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-sp]
-
 name: simd_fprint_doublev4
 params:
 -
  FILE *file:
 -
  doublev4 va:
 desc: |
  doublev4类型的数据以4个double的形式打印到文件file中。
 eg: |
  va=simd_set_doublev4(1.0,2.0,3.0,4.0);
  simd_fprint_doublev4(stderr, va);
  打印的结果是这样的：
  [ 4.0，3.0，2.0, 1.0 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_intv8
 params:
 -
  intv8 va:
 desc: |
  intv8类型的数据以8个int的形式打印到屏幕。
 eg: |
  va=simd_set_intv8(1,2,3,4,5,6,7,8);
  simd_print_intv8(va);
  打印的结果是这样的：
  [8，7，6，5，4, 3, 2, 1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_uintv8
 params:
 -
  uintv8 va:
 desc: |
  uintv8类型的数据以8个int的形式打印到屏幕。
 eg: |
  va=simd_set_uintv8(1,2,3,4,5,6,7,8);
  simd_print_uintv8(va);
  打印的结果是这样的：
  [8，7，6，5，4, 3, 2, 1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_int256
 params:
 -
  int256 va:
 desc: |
  int256类型的数据以4个long的形式打印到屏幕。
 eg: |
  va=simd_set_int256(1,2,3,4);
  simd_print_int256(va);
  打印的结果是这样的：
  [ 0x4, 0x3, 0x2, 0x1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_uint256
 params:
 -
  uint256 va:
 desc: |
  uint256类型的数据以4个long的形式打印到屏幕。
 eg: |
  va=simd_set_uint256(1,2,3,4);
  simd_print_uint256(va);
  打印的结果是这样的：
  [ 0x4, 0x3, 0x2, 0x1 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_floatv4
 params:
 -
  floatv4 va:
 desc: |
  floatv4类型的数据以4个float的形式打印到屏幕。
 eg: |
  va=simd_set_floatv4(1.0,2.0,3.0,4.0);
  simd_print_floatv4(va);
  打印的结果是这样的：
  [ 3.0，4.0，2.0, 1.0 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-sp]
-
 name: simd_print_doublev4
 params:
 -
  doublev4 va:
 desc: |
  doublev4类型的数据以4个double的形式打印到屏幕。
 eg: |
  va=simd_set_doublev4(1.0,2.0,3.0,4.0);
  simd_print_doublev4(va);
  打印的结果是这样的：
  [ 4.0，3.0，2.0, 1.0 ]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
