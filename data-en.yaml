-
 name: athread_init
 params:
 -
  return int: |
   Success: Returns 0, indicating that the acceleration thread initialization was successful;
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_init () will fail and return the corresponding value:
   -EINVAL: Initialization failed.
 cates: [Athread]
 tags: [MPE]
 desc: |
  To complete the initialization of the accelerated thread library, you must call this interface before using any thread library interface.
 header: "athread.h"
# inst: test1
# op: |
# c = a + b
# return c
-
 name: athread_create
 params:
 -
  int id: thread binding ID number
 -
  start_routine fpc: function pointer
 -
  void * arg: the starting address of the parameter of function f
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_create () will fail and return the corresponding value:
   -EAGIAN: The system limit was exceeded and too many threads were created.
   -EINVAL: The ID number is illegal (negative, or exceeds the maximum number of threads); or the ID number is already occupied and the occupied resources are not released.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Add a new controlled thread in the current process. The starting task executed by the thread is specified by the function fpc; the parameters of the function fpc are provided by arg.
  After the thread is bound to the ID number, the thread position has nothing to do with the ID number. If you need to know the information of the secondary core resources occupied by the thread in the core group, you can call the relevant interface to get this type of information.
-
 name: athread_wait
 params:
 -
  int id: waiting thread id number
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error
   -ESRCH: The thread corresponding to the specified thread ID was not found.
   -EINVAL: The ID number is illegal.
 desc: |
  Explicitly block the calling thread until the specified thread terminates. The specified thread must be in the current process.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_end
 params:
 -
  int id: Specify the thread ID number
 -
  return int: |
   Success: returns 0, the slave core resource occupied by the thread is successfully closed.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_end () will fail and return the corresponding value.
   -ESRCH: The thread corresponding to the given thread ID was not found.
   -EINVAL: The thread failed to terminate from the core pipeline, and the thread corresponding to the ID is still running.
 desc: |
  After determining that the slave core has no related operations, the slave core pipeline is stalled, and the slave core is shut down.
  You must ensure that there are no user jobs for the slave core to use this function.
 eg: |
  typedef void * (* start_routine) (void *);
  int fun (void * arg) {
    retrun (int) arg [0] + (int) arg [1];
  }
  main () {
    int tid1, tid2;
    int arg1 [2], arg2 [2];
    // Thread library initialization
    athread_init ();
    // Create a binding thread, the thread ID number is 0
    arg1 [0] = 1;
    arg1 [1] = 2;
    athread_create (0, fun, arg1);
    // Create a binding thread, the thread ID number is 1
    arg2 [0] = 3;
    arg2 [1] = 4;
    athread_create (1, fun, arg2);
    // Wait for the thread to end
    athread_wait (0);
    athread_wait (1);
    // Close the slave core pipeline occupied by the thread, and the slave core cannot continue to be used in this process
    athread_end (0);
    athread_end (1);
  }
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn
 params:
 -
  start_routine fpc: function pointer;
 -
  void * arg: The starting address of the parameter of function f.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates that an error has occurred. If any of the following conditions are detected, athread_spawn () will fail and return the corresponding value.
   -EINVAL: Thread group creation failed.
 desc: |
  Add a new controlled thread group in the current process. The task performed by the thread is specified by the function fpc; the parameters of the function fpc are provided by arg.
  When the athread_spawn interface is called, all available slave core resources in the core group are started. If you need to know the secondary core resource information occupied by the thread group in the core group, you can call the relevant interface to get this type of information.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_join
 params:
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error
   -EINVAL: No thread group is running in the core group.
 desc: |
  Explicitly block waiting for the thread group until the specified thread group is terminated. The specified thread group must be in the current process.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_halt
 desc: |
  After determining that all slave cores have no related operations, the slave core group pipeline is stopped, and the slave core group is shut down.
  You must ensure that there is no user job for the slave core group to use this function.
 params:
 -
  return int: |
   Success: returns 0, the slave core resource occupied by the thread is successfully closed.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_halt () will fail and return the corresponding value.
   -EINVAL: The secondary nuclear resource cannot be shut down normally.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn_group
 desc: |
  Add a new controlled thread group with mask code in the current process. The task performed by the thread is specified by the function fpc; the parameters of the function fpc are provided by arg.
  When the athread_spawn_group interface is called, all slave core resources in the shield code are started. If you need to know the secondary core resource information occupied by the thread group in the core group, you can call the relevant interface to get this type of information.
 params:
 -
  unsigned long gmask: mask code from the core;
 -
  start_routine fpc: function pointer;
 -
  void * arg: The starting address of the parameter of function f.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_spawn_group () will fail and return the corresponding value.
   -EINVAL: Thread group creation failed.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_join_group
 desc: |
  Explicit blocking waits for the end of the task of the thread group with the mask code until the specified thread group terminates and exits the interface. The specified thread group must be in the current process.
 params:
 -
  unsigned long gmask: mask code from the core
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error
   -EINVAL: No thread group is running in the core group.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_task
 desc: |
  Create a preemptive dynamic scheduling main core thread. The executed thread task is specified by the function fpc; arg is specified by the user, the total number of thread tasks, the value represents the judgment flag of the end of the task.
 params:
 -
  start_routine fpc: function pointer;
 -
  void * arg: total number of tasks
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error
   -EINVAL: Thread group creation failed.
 header: athread.h
 tags: [MPE]
 cates: [Athread]
-
 name: athread_spawn_task
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Create a preemptive dynamic scheduling slave core thread group. The executed thread task is specified by the function fpc; arg is specified by the user, the total number of thread tasks, the value represents the judgment flag of the end of the task.
  Since the master-slave core code uses different compilers, the code compiled by the slave core cannot be called by the master core, and vice versa, the user must ensure that the preemption tasks involved in the master core and slave core have their own corresponding code and compilation support.
 params:
 -
  start_routine fpc: function pointer;
 -
  void * arg: total number of tasks
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_spawn_task () will fail and return the corresponding value.
   -EINVAL: Thread group creation failed.
-
 name: athread_get_max_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Use this interface to get the total number of all core group thread resources available for the current process.
 params:
 -
  return int: |
   Success: Returns the maximum number of threads available in the core group (1 <= ret <= 64);
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_get_max_threads will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
-
 name: athread_set_num_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Use this interface to set the total number of all core group threads started in the next parallel zone of the current process.
 params:
 -
  int num: total number of threads
 -
  return int: |
   Success: 0;
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_set_num_threads will fail and return the corresponding value.
   -EAGAIN: Set the number of threads to exceed the available thread resources, this value will be returned.
   -EINVAL: Failed to set the number of threads in the parallel area, for example, the task of the previous parallel area was not completed.
-
 name: athread_get_num_threads
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Use this interface to get the total number of all core group threads started by the current process.
 params:
 -
  return int: |
   Success: Returns the number of threads in the current core group (1 <= ret <= 64);
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_get_num_threads will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
-
 name: athread_cancel
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  This function is used to terminate the specified thread, and the thread ID and resources can be recovered immediately.
  The end of the thread can be terminated by the following methods:
  Return from the first process of the thread, that is, the thread's startup routine. Refer to athread_create.
  Call athread_cancel to exit early.
 params:
 -
  int id: specify the exit thread number
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_cancel will fail and return the corresponding value.
   -ESRCH: The thread corresponding to the specified thread ID was not found.
   -EINVAL: The ID number is illegal.
   -EFAULT: The ID thread corresponds to the slave core failure.
-
 name: athread_signal
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  Receive an interrupt and specify the interrupt processing function.
  Refer to the athread_sigqueue () interface.
 params:
 -
  int signo: interrupt signal
 -
  start_routine fpc: interrupt handler function
 -
  return void:
-
 name: Exception_Kind
 params:
 -
  enum UNALIGN: out of bounds exception
 -
  enum ILLEGAL: illegal instruction
 -
  enum OVI: integer overflow
 -
  enum INE: inexact results
 -
  enum UNF: underflow
 -
  enum OVF: overflow
 -
  enum DBZ: divisor is 0
 -
  enum INV: invalid operation
 -
  enum DNO: denormalized number
 -
  enum CLASSE1: classification counter overflow
 -
  enum CLASSE2: abnormal classification parameter setting
 -
  enum SELLDWE: Vector lookup table is abnormal
 -
  enum LDME: LDM related exception
 -
  enum SDLBE: Unauthorized or out of bounds occurred during SDLB replacement
 -
  enum MABC: The address to access the main memory exceeds the actual configured capacity of the main memory
 -
  enum MATNO: main memory access target core group is not in place
 -
  enum RAMAR: Received memory access exception error response from the core
 -
  enum IFLOWE: abnormal instruction flow
 -
  enum SBMDE1: SBMD match exception and SBMD query exception
 -
  enum SBMDE2: Other SBMD anomalies
 -
  enum SYNE1: The synchronization vector sent from the core does not contain the current core
 -
  enum SYNE2: degradable synchronization is not enabled
 -
  enum RCE: abnormal communication
 -
  enum DMAE1: DMA generates DMA descriptor static check exception
 -
  enum DMAE2: DMA generates DMA descriptor static check warning
 -
  enum DMAE3: reserved
 -
  enum DMAE4: It is possible that the access address exceeds the LDM capacity during the use of row collection mode
 -
  enum DMAE5: reserved
 -
  enum IOE1: access reserved IO space address
 -
  enum IOE2: Unauthorized access to IO
 -
  enum IOE3: IO is not accessible
 -
  enum OTHERE: all kinds of exceptions that users don't care about
 -
  return enum:
 desc: the type of exception that can be mounted
-
 name: athread_expt_signal
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Mount specific exception handling functions.
  a: Exception type:
    According to Shenwei 26011 slave nuclear exception type, users can mount 32 exception handling signals in Exception_Kind.
  b: Mounting method
    athread_expt_signal (int exceptnum, void * handler)
  c: exception handling function
    The prototype of the user-defined exception handling function is:
    handler_t * handler (int signum, siginfo_t * sinfo, struct sigcontext * sigcontext)
    The first parameter: signum is an abnormal signal
    The second parameter: sinfo information is as follows:
    sinfo-> si_signo = signum; // abnormal signal
    sinfo-> si_pid = peid; // Abnormal slave core number
    sinfo-> si_uid = cgid; // Abnormal core group number
    
    The third parameter: The first three parameters of sigcontext are used to retain specific information, as follows:
    sigcontext-> sc_onstack // Whether the slave nuclear abnormal PC is accurately marked
    sigcontext-> sc_pc // From abnormal nuclear PC
    sigcontext-> sc_mask // Abnormal access to information from nuclear data stream
    If sc_pc is 0, there is no abnormal PC. If it is not 0, judge whether it is an accurate PC according to sc_onstack.
    When sc_onstack is 0, there is no precise abnormal PC. At this time, sc_pc records the inaccurate PC when the exception occurs; sc_onstack is 1 indicates that there is a precise abnormal PC. At this time, sc_pc records the accurate PC when the exception occurs;
    The sc_mask item is only valid for the data flow exception DFLOWE. 4b`0001 means LD main memory, 4b`0010 means ST main memory, 4b`0100 means DMA_GET, and 4b`1000 means DMA_PUT.
    The contents of other fields of sigcontext are determined by os and passed to the user processing program as they are.
    When an exception occurs, the thread library will report the first caught exception. This exception can be a core group exception or a slave core exception. If the user does not mount the corresponding handler for the exception, the thread library will print all the information related to the exception, halt the abnormal slave core, and exit the program; if the user mounts the handler for the exception, enter the user-defined Exception handling function.
    (For parallel C library: athread_expt_signal_for_ccc (void * handler)
    The parallel C library uses this function to mount all abnormal events. When an exception occurs, it will enter the exception function defined by the parallel C library for processing. The parameters of the handler function are as follows:
    void handle (int sig, siginfo_t * sinfo, struct sigcontext * sigcontext)
    The content of the above three parameters is determined by the operating system and passed to the parallel C library exception handling function as is
    )
 params:
 -
  int signo: abnormal signal
 -
  start_routine fpc: exception handling function
-
 name: IO_addr
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  The master core can access the local storage through IO. This macro returns the IO address of the slave core LDM variable element.
  The IO_addr macro does not judge the legality of penum and cgnum, and is guaranteed by the user.
 params:
 -
  element: Locally stored private variable __thread_local elment in the core program, extern __thread must be added as an external variable before the master core uses the IO_addr interface
 -
  penum: nuclear number
 -
  cgnum: nuclear group number
 -
  return: return IO address
 eg: |
  From the nuclear program slave.c:
    __thread_local char ch = 'b';
    __thread_local long para [10] __attribute __ ((__ aligned __ (128))) = {0x123, 0x234, 0x345, 0x456};
  Main nuclear program main.c:
    extern long __thread para [];
    extern char __thread ch;
    unsigned long LDM_addr;
    LDM_addr = IO_addr (para [0], 23, 0);
  In this way, LDM_addr is equal to the IO address of para [0] on the secondary core of core group 0
-
 name: h2ldm
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  The master core can access the local storage through IO, this macro directly performs IO access operations on the slave core LDM variable element in the master core
  The h2ldm macro does not judge the legality of penum and cgnum, and is guaranteed by the user.
 params:
 -
  element: Locally stored private variable __thread_local elment in the core program, extern __thread must be added as an external variable before the master core uses the IO_addr interface
 -
  penum: nuclear number
 -
  cgnum: nuclear group number
 -
  return:
 eg: |
  From the nuclear program slave.c:
    __thread_local char ch = 'b';
    __thread_local long para [10] __attribute __ ((__ aligned __ (128))) = {0x123, 0x234, 0x345, 0x456};
  Main nuclear program main.c:
    extern long __thread para [];
    extern char __thread ch;
    unsigned long LDM_addr;
    h2ldm (para [0], 23, 0) = 0xaaa;
    h2ldm (ch, 5, 1) = 'z';
  The master checks the assignment of the local storage variable para [0] on the 23rd slave core of the No. 0 core group; the master checks the assignment of the local storage variable ch on the 5th slave core of the No. 1 core group.
  Remarks:
    The thread create and spawn interfaces have only one parameter interface. The master core access slave storage interface can be used as the master core to perform batch parameter assignment for the core group acceleration area. For example: the slave core program specifically applies for a local storage space for storing parameters. The master core can assign values ​​to this parameter area before starting different acceleration areas; if the same parameters are assigned to each slave core, it is usually best practice It is to assign parameters to only one slave core, and then the slave core broadcasts the parameters to all slave cores on the core group through register communication.
-
 name: athread_idle
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc:
  Use this function to obtain whether the current slave core thread group is idle.
  The idle state here refers to a state of waiting for a task, that is, the thread group does not execute the slave core acceleration thread of the user spawn or the thread group has completed the user spawn slave core acceleration thread.
 params:
 -
  return unsigned long: |
   If the slave core group is idle, it returns the currently available slave core bitmap; otherwise, it returns 0.
 eg: |
  unsigned long idleslave;
  if (idleslave = athread_idle ())
  {
    Use slave optimization (spawn);
    ...
  }
-
 name: athread_task_info
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Query the number of core groups participating in the task execution and the core group number of the current core group in the CPU where the task is located. Obtain the corresponding value by looking at the internal library variables __cgid / __ cgnum respectively.
  Before calling this interface, you must first call athread_task_info to initialize __cgid and __cgnum, and notify the number of core groups participating in synchronization through internal variables.
  The interface will occupy 64B (0x6000000000 ~ 0x6000000000 + 0x40) of the data before the cross section as the lock space. Users need to avoid this space when using this interface to prevent unpredictable errors.
-
 name: athread_master_sync
 header: athread.h
 tags: [MPE]
 cates: [Athread]
 desc: |
  Synchronization between core groups.
  Before calling this interface, you must first call athread_task_info to initialize __cgid and __cgnum, and notify the number of core groups participating in synchronization through internal variables.
  The interface will occupy 64B (0x6000000000 ~ 0x6000000000 + 0x40) of the data before the cross section as the lock space. Users need to avoid this space when using this interface to prevent unpredictable errors.

-
 name: athread_get_id
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  Use this function to obtain the logical identification number (ie ID number) of the local single thread. This interface is common to the master and slave cores.
  As long as the thread is started with athread_create to create a single-threaded interface, there will be a bound identifier.
 params:
 -
  int core: Specifies to query the physical core number, -1 default local slave core (the slave core interface is valid).
 -
  return int: |
   Success: the logical ID number of the thread (0 <= ret <= 63).
   Failure: Any other return value indicates an error. If any of the following conditions are monitored, athread_get_id will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
 eg: |
  int myid;
  myid = athread_get_id (-1);
-
 name: athread_get_core
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  Use this interface to obtain the physical slave core number of the corresponding thread. This interface is common to the master and slave cores.
  The lower 6 digits of the return value are valid, the lower 3 digits are the column number, and the upper 3 digits are the row number, which respectively represent the core group 8 * 8 array.
 params:
 -
  int id: Specify the query thread number, -1 default local thread (valid from the core interface)
 -
  return int: |
   Success: The physical core number occupied by the thread (0 <= ret <= 63).
   Failure: Any other return value indicates an error. If any of the following conditions are monitored, athread_get_core will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
 eg: |
  int mycore;
  mycore = athread_get_core (-1);
-
 name: athread_sigqueue
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  The slave core sends an asynchronous interrupt carrying a message to the master core. After the interrupt is issued, the slave core does not wait for the master core to receive the interrupt and complete the interrupt processing function, but continues to execute subsequent slave core code.
 params:
 -
  int pid: main process, represented by 0
 -
  int signo: break number
 -
  const union sigval value: interrupt message
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_sigqueue () will fail and return the corresponding value.
   -EINVAL: signo is invalid, or sending a message fails.
 eg: |
  How to properly mount an interrupt handler function:
  Assuming that the master-slave core agrees that when the slave core sends a SW3_SIGMAX-1 signal, the master core calls the interrupt handler x_handler.
  From the nuclear program:
  a = 1234567890;
  fun ()
  {
    // The interrupt signal SW3_SIGMAX-1
    // And interrupt carrying information & a sent to the main process.
    athread_sigqueue (0, SW3_SIGMAX-1, & a)
  }
  Main nuclear program:
    x_handler (int sig, siginfo_t * sinfo, struct sigcontext * sigcontext)
  {
    union sigval sv;
    printf ("x_handler begin! \ n");
    // sv == Carry information from nuclear interrupt & a
    sv = sinfo-> si_value;
  }
  main ()
  {
    athread_signal (SW3_SIGMAX-1, x_handler); // Consistent with usage of signal
  }
-
 name: athread_sigsend
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  The slave core sends a message-carrying synchronous interrupt to the master core. After the interrupt is issued, the slave core waits for the master core to receive the interrupt until it completes the interrupt processing function and can continue to execute the subsequent slave core code.
 params:
 -
  int pid: main process, represented by 0
 -
  int signo: break number
 -
  const union sigval value: interrupt message
 -
  return int: |
   Success: return 0;
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_sigsend () will fail and return the corresponding value.
   -EINVAL: signo is invalid, or sending a message fails.
 eg: |
  Refer to the description of athread_sigqueue.
-
 name: athread_get
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  The LDM from the core office receives the data of the main memory MEM, performs the data get operation from the main memory MEM to the slave core LDM, and gets the data of the MEM to the designated location of the LDM. The transmission mode is specified by mode. If it is in broadcast mode and broadcast line mode, mask register configuration is required; in other modes, the mask value is invalid.

 params:
 -
  dma_mode mode: DMA transfer command mode;
 -
  void * src: DMA transfer main memory source address;
 -
  void * dest: DMA transfer local local storage target address;
 -
  int len: the amount of DMA transfer data, in bytes;
 -
  void * reply: DMA transfer reply word address, which must be the local storage address, address 4B is delimited;
 -
  char mask: DMA transmission broadcast effective vector, the effective granularity is one line in the core group, and a bit of 1 indicates that the corresponding line transmission is effective, which acts on the broadcast mode and the broadcast line mode;
 -
  int stride: main memory strides, in bytes;
 -
  int bsize: In line set mode, it must be configured to indicate the size of the data granularity on each slave core; in other modes, it is effective in DMA stride transfer, indicating the size of the DMA transfer stride vector block, in bytes For the unit.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are monitored, athread_get will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
 eg: |
  __thread_local long ldm_a [64];
  __thread long mem_b [64];
  __thread_local int reply = 0;
  athread_get (PE_MODE, mem_a, ldm_a, 64 * 8, & reply, 0,0,0);
  // In single-slave core mode, the private continuous segment of the slave core uses mem_a as the base address to take 64 * 8B data into the continuous 64 * 8B space with the ldm_a as the base address from the core office, where the broadcast vector and the main memory span The step and vector block sizes are both 0.
-
 name: athread_put
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  Send data from the core LDM to the main memory MEM, perform a data put operation from the core LDM to the main memory MEM, and put the LDM data to the location specified by the MEM. The transmission mode is specified by mode and does not support broadcast mode and broadcast line mode.
  For the DMA transfer command mode, refer to the additional description of the athread_get interface
 params:
 -
  dma_mode mode: DMA transfer command mode;
 -
  void * src: DMA transfer local storage source address;
 -
  void * dest: DMA transfer main storage destination address;
 -
  int len: the amount of DMA transfer data, in bytes;
 -
  void * reply: DMA transfer reply word address, which must be the local storage address, address 4B is delimited;
 -
  int stride: main memory strides, in bytes;
 -
  int bsize: In line set mode, it must be configured to indicate the size of the data granularity on each slave core; in other modes, it is effective in DMA stride transfer, indicating the size of the DMA transfer stride vector block, in bytes For the unit.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_put will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
-
 name: athread_get_p
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  Physical address data reception, except that the source main storage address is a physical address, other usage methods are consistent with athread_get
 params:
 -
  dma_mode mode: DMA transfer command mode;
 -
  void * src: DMA transfer main memory source address;
 -
  void * dest: DMA transfer local local storage target address;
 -
  int len: the amount of DMA transfer data, in bytes;
 -
  void * reply: DMA transfer reply word address, which must be the local storage address, address 4B is delimited;
 -
  char mask: DMA transmission broadcast effective vector, the effective granularity is one line in the core group, and a bit of 1 indicates that the corresponding line transmission is effective, which acts on the broadcast mode and the broadcast line mode;
 -
  int stride: main memory strides, in bytes;
 -
  int bsize: In line set mode, it must be configured to indicate the size of the data granularity on each slave core; in other modes, it is effective in DMA stride transfer, indicating the size of the DMA transfer stride vector block, in bytes For the unit.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are monitored, athread_get will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
-
 name: athread_put_p
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  The physical address data is sent. Except that the destination main storage address is a physical address, other usage methods are the same as athread_put
 params:
 -
  dma_mode mode: DMA transfer command mode;
 -
  void * src: DMA transfer local storage source address;
 -
  void * dest: DMA transfer main storage destination address;
 -
  int len: the amount of DMA transfer data, in bytes;
 -
  void * reply: DMA transfer reply word address, which must be the local storage address, address 4B is delimited;
 -
  int stride: main memory strides, in bytes;
 -
  int bsize: In line set mode, it must be configured to indicate the size of the data granularity on each slave core; in other modes, it is effective in DMA stride transfer, indicating the size of the DMA transfer stride vector block, in bytes For the unit.
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are detected, athread_put will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.

-
 name: athread_dma_barrier
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  Initiate dma fence, the corresponding dma command opcode is barrier_group
-
 name: scope
 params:
 -
  enum ROW_SCOPE: row synchronization, the lower 8 bits are valid
 -
  enum COL_SCOPE: column synchronization, the lower 8 bits are valid
 -
  enum ARRAY_SCOPE: full core group synchronization, the lower 16 bits are effective, of which the lower 8 bits of 16 bits are column synchronization mask codes and the upper 8 bits are row synchronization mask codes
 -
  return enum:
 desc:
  The synchronization domain of athread_syn.
-
 name: athread_syn
 header: slave.h
 tags: [CPE]
 cates: [Athread]
 desc: |
  The slave cores are controlled synchronously within the core group.
 params:
 -
  scope scp: synchronization scope control
 -
  int mask: synchronous mask code
 -
  return int: |
   Success: 0 is returned.
   Failure: Any other return value indicates an error. If any of the following conditions are monitored, athread_syn will fail and return the corresponding value.
   -EINVAL: Return failed with an exception.
-
 name: get_allocatable_size
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  Get the current size of the LDM space that can be dynamically allocated, that is, the size of the LDM space managed by the local storage dynamic allocation runtime library
 params:
 -
  return size_t:
-
 name: ldm_malloc
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  Local storage space application.
 params:
 -
  size_t size: size of space in bytes
 -
  return void *: |
   Successfully returned the starting address of the allocated LDM space;
   Failure to return NULL;
-
 name: ldm_free
 header: slave.h
 tags: [CPE]
 cates: [LDM Malloc]
 desc: |
  The local storage space is released, and the starting address of the free space is addr.
 params:
 -
  void * addr: It must be the local storage address returned by ldm_malloc in a previous successful allocation;
 -
  size_t size: Shows the size of the specified free space, generally must match the size of ldm_malloc in the previous one
-
 name: dma_mode
 params:
 -
  enum PE_MODE: single slave core mode
 -
  enum BCAST_MODE: broadcast mode
 -
  enum ROW_MODE: row mode
 -
  enum BROW_MODE: broadcast line mode
 -
  enum RANK_MODE: row collection mode
 -
  return enum:
 desc: DMA command mode used in data DMA.
-
 name: dma_op
 params:
 -
  enum DMA_PUT: store data from core to main memory
 -
  enum DMA_GET: get data from main memory from core
 -
  enum DMA_PUT_P: store data from core to main memory (physical address)
 -
  enum DMA_GET_P: get data from core from main memory (physical address)
 -
  enum DMA_BARRIER: DMA fence
 -
  return enum:
 desc: DMA operation type.
-
 name: dma_set_size
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  int size:
 -
  return void:
 desc: |
  Set the data transmission attribute of the dma descriptor.
  Data transfer volume
 eg: |
  dma_set_size (dma_d, 256);
-
 name: dma_set_reply
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  int * reply:
 -
  return void:
 desc: |
  Set the answer word attribute of the dma descriptor.
 eg: |
  __thread_local reply;
  dma_set_reply (dma_d, & reply);
-
 name: dma_set_op
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  dma_op op:
 -
  return void:
 desc: |
  Set the dma operation attribute of the dma descriptor.
 eg: |
  dma_set_op (dma_d, DMA_PUT);
-
 name: dma_set_mode
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  dma_mode mode:
 -
  return void:
 desc: Set the dma mode attribute of the dma descriptor.
 eg: |
  dma_set_op (dma_d, PE_MODE);
-
 name: dma_set_mask
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  int mask:
 -
  return void:
 desc: |
  Set the mask code attribute of the dma descriptor.
  Only for broadcast and broadcast line mode
 eg: |
  dma_set_mask (dma_d, 1);
-
 name: dma_set_bsize
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  int bsize:
 -
  return void:
 desc: |
  Set the dma descriptor's stride vector block size attribute.
  Only used in stride mode and row collection mode;
  TODO in broadcast mode
  In row set mode, bsize is the block size transferred to each slave core.
 eg: |
  dma_set_bsize (dma_d, 0x32);
-
 name: dma_set_stepsize
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc * dma_d:
 -
  int length:
 desc: |
  Set the main memory stride length attribute of the dma descriptor.
  Only used in stride mode and row collection mode;
  TODO in broadcast mode
 eg: |
  dma_set_stepsize (dma_d, 0x128);
-
 name: dma
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  dma_desc dma_d:
 -
  long mem:
 -
  long ldm:
 inst: dma
 desc: |
  Initiate dma according to the dma descriptor, main storage start address and local storage start address specified by the parameters
-
 name: dma_wait
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 params:
 -
  int * reply:
 -
  int count:
 desc:
   Wait according to the address of the answer word specified by the parameter until the value of the answer word is equal to count
-
 name: dma_barrier
 header: dma.h
 tags: [CPE]
 cates: [DMA]
 inst: dma
 desc:
  Initiate the dma fence of this slave core
-
 name: simd_load
 desc: |
  For extended type loading, 32 bytes (floatv4 type loading is 16 bytes) of data is loaded into a vector variable from the continuous memory area.
  The memory address loaded must be 32 bytes aligned.
 params:
 -
  intv8 va: the result is stored in va
 -
  int * addr: address to be loaded
 cates: [SIMD, SIMD-load, SIMD-int]
 tags: [CPE, MPE]
 header: simd.h
 inst: vldd
-
 name: simd_load
 desc: |
  For extended type loading, 32 bytes (floatv4 type loading is 16 bytes) of data is loaded into a vector variable from the continuous memory area.
  The memory address loaded must be 32 bytes aligned.
 params:
 -
  doublev4 va: the result is stored in va
 -
  double * addr: address to be loaded
 cates: [SIMD, SIMD-load, SIMD-dp]
 tags: [CPE, MPE]
 header: simd.h
 inst: vldd
-
 name: simd_load
 desc: |
  For extended type loading, 32 bytes (floatv4 type loading is 16 bytes) of data is loaded into a vector variable from the continuous memory area.
  The loaded memory address must be 16 bytes aligned.
 params:
 -
  floatv4 va: The result is stored in va
 -
  float * addr: address to be loaded
 cates: [SIMD, SIMD-load, SIMD-sp]
 tags: [CPE, MPE]
 header: simd.h
 inst: vlds
-
 name: simd_loade
 desc: |
  Load and expand the extended type, load 8-byte (floatv4 type load is 4 bytes) data from the continuous memory area into the lower 64 bits of a vector variable, and expand the data to the upper 192 Bit, so that the four registers of the vector register have the same value. intv8 takes 4 bytes and then expands into 8 components.
 params:
 -
  intv8 va: the result is stored in va
 -
  int * addr: address to be loaded
 inst: ldwe
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-int]
-
 name: simd_loade
 desc: |
  Load and expand the extended type, load 8-byte (floatv4 type load is 4 bytes) data from the continuous memory area into the lower 64 bits of a vector variable, and expand the data to the upper 192 Bit, so that the four registers of the vector register have the same value. intv8 takes 4 bytes and then expands into 8 components.
 params:
 -
  doublev4 va: the result is stored in va
 -
  double * addr: address to be loaded
 inst: ldde
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-dp]
-
 name: simd_loade
 desc: |
  Load and expand the extended type, load 8-byte (floatv4 type load is 4 bytes) data from the continuous memory area into the lower 64 bits of a vector variable, and expand the data to the upper 192 Bit, so that the four registers of the vector register have the same value. intv8 takes 4 bytes and then expands into 8 components.
 params:
 -
  floatv4 va: The result is stored in va
 -
  float * addr: address to be loaded
 inst: ldse
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-sp]
-
 name: simd_store
 desc: |
  Extended type storage, the data in a vector variable is stored in a continuous memory area of ​​32 bytes (floatv4 type load is 16 bytes).
 params:
 -
  intv8 va: vector to be stored
 -
  int * addr: stored address
 inst: vstw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-int]
-
 name: simd_store
 desc: |
  Extended type storage, the data in a vector variable is stored in a continuous memory area of ​​32 bytes (floatv4 type load is 16 bytes).
 params:
 -
  doublev4 va: vector to be stored
 -
  double * addr: stored address
 inst: vstd
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-dp]
-
 name: simd_store
 desc: |
  Extended type storage, the data in a vector variable is stored in a continuous memory area of ​​32 bytes (floatv4 type load is 16 bytes).
 params:
 -
  floatv4 va: vector to be stored
 -
  float * addr: stored address
 inst: vsts
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-sp]
-
 name: simd_loadu
 desc: |
  Extended type of non-aligned loading, 32 bytes (floatv4 type loading is 16 bytes) length of data from a continuous memory area is loaded into a vector variable.
 params:
 -
  intv8 va: the result is stored in va
 -
  int * addr: loaded address
 inst: vldw_ul, vldw_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-int]
-
 name: simd_loadu
 desc: |
  Extended type of non-aligned loading, 32 bytes (floatv4 type loading is 16 bytes) length of data from a continuous memory area into a vector variable.
 params:
 -
  doublev4 va: the result is stored in va
 -
  double * addr: loaded address
 inst: vldd_ul, vldd_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-dp]
-
 name: simd_loadu
 desc: |
  Extended type of non-aligned loading, 32 bytes (floatv4 type loading is 16 bytes) length of data from a continuous memory area into a vector variable.
 params:
 -
  floatv4 va: The result is stored in va
 -
  float * addr: loaded address
 inst: vlds_ul, vlds_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-load, SIMD-sp]
-
 name: simd_storeu
 desc: |
  The non-boundary storage of the extended type stores the data in a vector variable into a continuous memory area of ​​32 bytes (the floatv4 type is 16 bytes).
 params:
 -
  intv8 va: vector to be stored
 -
  int * addr: stored address
 inst: vstw_ul, vstw_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-int]
-
 name: simd_storeu
 desc: |
  The non-boundary storage of the extended type stores the data in a vector variable into a continuous memory area of ​​32 bytes (the floatv4 type load is 16 bytes).
 params:
 -
  doublev4 va: vector to be stored
 -
  double * addr: stored address
 inst: vstd_ul, vstd_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-dp]
-
 name: simd_storeu
 desc: |
  The non-boundary storage of the extended type stores the data in a vector variable into a continuous memory area of ​​32 bytes (the floatv4 type load is 16 bytes).
 params:
 -
  floatv4 va: vector to be stored
 -
  float * addr: stored address
 inst: vsts_ul, vsts_uh
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-store, SIMD-sp]
-
 name: simd_vaddw
 desc: |
  Intv8 type addition adds 8 int integer data types in va to 8 int integer data types or 8-bit immediate data b in vb. You can use the "+" symbol to replace.
 params:
 -
  intv8 va: the first addend
 -
  intv8 vb: second addend
 -
  return intv8: va + vb
 inst: vaddw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsubw
 desc: |
  The intv8 type of subtraction subtracts the 8 int type integer data in va and the 8 int type integer data in vb or the 8-bit immediate value b. You can use the "-" symbol to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va-vb
 inst: vsubw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vandw
 desc: |
  The logical AND of the intv8 type performs logical AND operation on the 8 int integer data in va and the 8 int integer data in vb or the 8-bit immediate data b, respectively. You can use the "&" symbol to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va & vb
 inst: vandw / vlogc0
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vbicw
 desc: |
  The logic NAND of intv8 type is to perform logic NAND operation on the 8 int integer data in va and the 8 int integer data in vb or the 8-bit immediate data b. You can use "&" and "~" symbols to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va & ~ vb
 inst: vbicw / vlog30
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vbisw
 desc: |
  The logical OR of intv8 type performs logical OR operation on the 8 int integer data in va and the 8 int integer data or 8-bit immediate data b in vb, respectively. You can use the "|" symbol to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va | vb
 inst: vbisw / vlogfc
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vornotw
 desc: |
  The logical NOR of intv8 type is to perform logical NAND operation on the 8 int integer data in va and the 8 int integer data or 8-bit immediate data b in vb. You can use "|" and "~" symbols to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va | ~ vb
 inst: vlogf3
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vxorw
 desc: |
  The logical exclusive OR of intv8 type performs logical exclusive OR operation on the 8 int integer data in va and the 8 int integer data or 8-bit immediate data b in vb, respectively. You can use the "^" symbol to replace.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va ^ vb
 inst: vxorw / vlog3c
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_veqvw
 desc: |
  The logical equivalent of the intv8 type, the 8 int type integer data in va and the 8 int type integer data in vb or the 8-bit immediate data b corresponding to the bit-wise logical equivalent (same or) Save to return value.
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: ~ (va ^ vb)
 inst: veqvw / vlogc3
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsllw
 desc: |
  Intv8 type logical left shift, logically shift the 8 int type integer data in va, the vacant bits removed are supplemented with "0", the number of shifted digits of the four numbers is the same, the lowest 5 bits in b Or decide immediately. You can use the "<<" symbol to replace.
 params:
 -
  intv8 va:
 -
  int b:
 -
  return intv8: va << b
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = va [i] << b;
  return vc;
 inst: vsllw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsrlw
 desc: |
  Logic right shift of intv8 type, logical shift right of 8 int integer data in va, the vacant bits removed are supplemented by "0", the number of shifts of the four numbers is the same, and the lowest 5 bits in b Or a 5-digit immediate decision. You can use the ">>" symbol to replace. When using the ">>" symbol, if the operand is signed, the vsraw instruction is generated, if it is unsigned, the vsrlw instruction is generated.
 params:
 -
  intv8 va:
 -
  int b:
 -
  return intv8: va >>> b
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = va [i] >>> b; // vc [i] = ((unsigned int) va [i]) >> b;
  return vc;
 inst: vsrlw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vsraw
 desc: |
  Intv8 type arithmetic right shift, logically shift the 8 int type integer data in va, the vacated bits are supplemented with the original sign bit, the number of shifts of the four numbers is the same, the lowest 5 bits in b Or a 5-digit immediate decision. You can use the ">>" symbol to replace. When using the ">>" symbol, if the operand is signed, the vsraw instruction is generated, if it is unsigned, the vsrlw instruction is generated.
 params:
 -
  intv8 va:
 -
  int b:
 -
  return intv8: va >> b
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = va [i] >> b;
  return vc;
 inst: vsraw
 header: simd.h
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vcmpeqw
 header: simd.h
 inst: vcmpeqw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va == vb
 desc: |
  Perform an equal comparison operation on the 8 32-bit word integer vector elements in Va and the corresponding 8 32-bit word integer vector elements in Vb (or 8-bit immediate #b), if the specified relationship is satisfied, the corresponding in Vc The word element is "1", otherwise it is "0".
 op: |
  for (i = 0; i <8; i ++)
    if ((int) va [i] == (int) vb [i])
      vc [i] = 1;
    else
      vc [i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmplew
 header: simd.h
 inst: vcmplew
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: a <= b
 desc: |
  Perform 8 or less 32-bit word integer vector elements in Va and 8 corresponding 32-bit word integer vector elements in Vb (or 8-bit immediate number #b) respectively. The word element is "1", otherwise it is "0".
 op: |
  for (i = 0; i <8; i ++)
    if ((int) va [i] <= (int) vb [i])
      vc [i] = 1;
    else
      vc [i] = 0;
  return vc;
-
 name: simd_vcmpltw
 header: simd.h
 inst: vcmpltw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: va <vb
 desc: |
  The 8 32-bit word integer vector elements in Va and the 8 32-bit word integer vector elements in Vb (or 8-bit immediate number #b) are respectively less than the comparison operation. The word element is "1", otherwise it is "0".
 op: |
  for (i = 0; i <8; i ++)
    if ((int) va [i] <(int) vb [i])
      vc [i] = 1;
    else
      vc [i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmpulew
 header: simd.h
 inst: vcmpulew
 params:
 -
  uintv8 va:
 -
  uintv8 vb:
 -
  return uintv8: va <= vb
 desc: |
  Perform unsigned less than or equal comparison operations on the 8 32-bit word integer vector elements in Va and the corresponding 8 32-bit word integer vector elements in Vb (or 8-bit immediate number # b) The corresponding word element in is "1", otherwise it is "0".
 op: |
  for (i = 0; i <8; i ++)
    if ((unsigned int) va [i] <= (unsigned int) vb [i])
      vc [i] = 1;
    else
      vc [i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vcmpultw
 header: simd.h
 inst: vcmpultw
 params:
 -
  uintv8 va:
 -
  uintv8 vb:
 -
  return uintv8: va <vb
 desc: |
  Perform unsigned less than comparison operations on the 8 32-bit word integer vector elements in Va and the corresponding 8 32-bit word integer vector elements in Vb (or 8-bit immediate #b). If the specified relationship is met, then Vc The corresponding word element is "1", otherwise it is "0".
 op: |
  for (i = 0; i <8; i ++)
    if ((unsigned int) va [i] <= (unsigned int) vb [i])
      vc [i] = 1;
    else
      vc [i] = 0;
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vrolw
 header: simd.h
 inst: vrolw
 params:
 -
  intv8 va:
 -
  int b:
 return intv8: (va << b) | (va >>> 32-b)
 desc: |
  Intv8 type circular left shift, the 8 int integer data in va are circular left shifted, the vacated bits are supplemented by the shifted out bits, the four digits are shifted by the same number of bits, the lower 5 bits of b or 5 The immediate number is determined.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = (va [i] << b) | (va [i] >>> (32-b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_sllow
 header: simd.h
 inst: sllow
 params:
 -
  int256 va:
 -
  int b:
 -
  return int256: va << b
 desc: |
  The whole 256 bits in Va are shifted to the left, and the vacated bits are filled with "0". The number of shifted bits is determined by the lower 8 bits of b or the immediate value of 8 bits.
 op: |
  vc [0] = va [0] << b;
  for (i = 1; i <8; i ++)
    vc [i] = (va [i] << b) | (va [i-1] >>> (32-b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_srlow
 header: simd.h
 inst: srlow
 params:
 -
  int256 va:
 -
  int b:
 -
  return int256: va >> b
 desc: |
  The whole 256 bits in Va are shifted to the right, the vacated bits are filled with "0", the number of shifts is determined by the lower 8 bits of b or the immediate value of 8 bits, and the result is written in Vc.
 op: |
  vc [7] = va [7] >> b;
  for (i = 0; i <7; i ++)
    vc [i] = (va [i] >> b) | (va [i + 1] << (32-b));
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vaddl
 header: simd.h
 inst: vaddl
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va + vb
 desc: |
  Add four 64-bit long words (or 8-bit immediate data b) in Va and Vb respectively, and save the result to the corresponding position in Vc.
 op: |
  (by long [4])
  for (i = 0; i <4; i ++)
    vc [i] = va [i] + vb [i];
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsubl
 header: simd.h
 inst: vsubl
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va-vb
 desc: |
  Subtract 4 64-bit long words (or 8-bit immediate data b) in Va and Vb respectively, and save the result to the corresponding position in Vc.
 op: |
  (by long [4])
  for (i = 0; i <4; i ++)
    vc [i] = va [i]-vb [i];
  return vc;
 tags: [CPE, MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_ctpopow
 header: simd.h
 inst: ctpopow
 params:
 -
  int256 va:
 -
  return int: sum (popcnt (va [i]))
 desc: |
  Returns the number of "1" s in the 256-bit octet integer in va.
 op: |
  int cnt = 0;
  for (i = 0; i <8; i ++) {
    for (j = 0; j <32; j ++)
      if ((va [i] >> j) & 1)
        cnt ++;
  }
  return cnt;
 tags: [MPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_ctlzow
 header: simd.h
 inst: ctlzow
 params:
 -
  int256 va:
 -
  return int:
 desc: |
  Returns the number of 256-bit octet integers in Va that are consecutive "0" from the highest bit.
 op: |
  int cnt = 0;
  for (i = 7; i> = 0; i-)
    for (j = 31; j> = 0; j-)
      if ((va [i] >> j) & 1)
        cnt ++;
      else
        return cnt;
  return cnt;
 tags: [MPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vucaddw
 header: simd.h
 inst: vucaddw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assuming that the value of va + vb is accurately represented, max (min (va + vb, 2147483647), -2147483648)
 desc: |
  The corresponding 8 32-bit word integers in Va and Vb (or 8-bit immediate #b zero-expanded word integers) are respectively 32-bit signed addition, and the lower 32-bit result is stored in Vc. If the result overflows, the corresponding 32-bit result is set to 0x7fff, ffff; if an underflow occurs, the corresponding 32-bit result is set to 0x8000,0000.
 op: |
  for (i = 0; i <8; i ++) {
    long tmp = (long) va [i] + (long) vb [i];
    if (tmp> 0x000000007fffffffLL)
      tmp = 0x000000007fffffff;
    if (tmp <0xffffffff80000000LL)
      tmp = 0xffffffff80000000;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubw
 header: simd.h
 inst: vucsubw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assuming that the value of va-vb is accurately represented, max (min (va-vb, 2147483647), -2147483648)
 desc: |
  The 8 corresponding 32-bit word integers in Va and Vb (or 8-bit immediate #b zero-expanded word integers) are respectively 32-bit signed subtraction, and the result of taking the lower 32 bits is saved to Vc. If the result overflows, the corresponding 32-bit result is set to 0x7fff, ffff; if an underflow occurs, the corresponding 32-bit result is set to 0x8000,0000.
 op: |
  for (i = 0; i <8; i ++) {
    long tmp = (long) va [i]-(long) vb [i];
    if (tmp> 0x000000007fffffffLL)
      tmp = 0x000000007fffffff;
    if (tmp <0xffffffff80000000LL)
      tmp = 0xffffffff80000000;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucaddh
 header: simd.h
 inst: vucaddh
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assume that the value of va + vb is accurately represented, max (min (va + vb, 65535), -65536)
 desc: |
  The 16 corresponding 16-bit halfword integers (or 8-bit immediate #b zero-expanded halfword integers) in Va and Vb are respectively added with 16 bits, and the result of taking the lower 16 bits is saved in Vc. If the result overflows, the corresponding 16-bit result is set to 0x7fff; if an underflow occurs, the corresponding 16-bit result is set to 0x8000.
 op: |
  (by short [16])
  for (i = 0; i <16; i ++) {
    int tmp = (int) va [i] + (int) vb [i];
    if (tmp> 0x00007fff)
      tmp = 0x00007fff;
    if (tmp <0xffff8000)
      tmp = 0xffff8000;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubh
 header: simd.h
 inst: vucsubh
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assume that the value of va-vb is accurately represented, max (min (va-vb, 65535), -65536)
 desc: |
  The 16 16-bit halfword integers (or 8-bit immediate #b zero-expanded halfword integers) corresponding to Va and Vb are respectively 16-bit signed subtraction, and the lower 16-bit result is stored in Vc. If the result overflows, the corresponding 16-bit result is set to 0x7fff; if an underflow occurs, the corresponding 16-bit result is set to 0x8000.
 op: |
  (by short [16])
  for (i = 0; i <16; i ++) {
    int tmp = (int) va [i]-(int) vb [i];
    if (tmp> 0x00007fff)
      tmp = 0x00007fff;
    if (tmp <0xffff8000)
      tmp = 0xffff8000;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucaddb
 header: simd.h
 inst: vucaddb
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assuming that the value of va + vb is accurately represented, max (min (va + vb, 255), -256)
 desc: |
  The corresponding 32 octet integers (or 8-bit immediate number #b) in Va and Vb are respectively added with 8 bits, and the result of taking the lower 8 bits is saved to Vc. If the result overflows, the corresponding 8-bit result is set to 0x7f; if an underflow occurs, the corresponding 8-bit result is set to 0x80.
 op: |
  (by char [32])
  for (i = 0; i <32; i ++) {
    int tmp = (short) va [i] + (short) vb [i];
    if (tmp> 0x007f)
      tmp = 0x007f;
    if (tmp <0xff80)
      tmp = 0xff80;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vucsubb
 header: simd.h
 inst: vucsubb
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: Assuming that the value of va-vb is accurately represented, max (min (va-vb, 255), -256)
 desc: |
  The corresponding 32 octet integers (or 8-bit immediate #b) in Va and Vb are respectively 8-bit signed subtraction, and the result of taking the lower 8 bits is saved to Vc. If the result overflows, the corresponding 8-bit result is set to 0x7f; if an underflow occurs, the corresponding 8-bit result is set to 0x80.
 op: |
  (by char [32])
  for (i = 0; i <32; i ++) {
    int tmp = (int) va [i]-(int) vb [i];
    if (tmp> 0x007f)
      tmp = 0x007f;
    if (tmp <0xff80)
      tmp = 0xff80;
    vc [i] = tmp;
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vseleqw
 header: simd.h
 inst: vseleqw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va == 0? vb: vc
 desc: |
  Perform an equal comparison test on each word element in Va and 0. If the condition is true, write the word element corresponding to vector Vb to the corresponding position of Vd, otherwise extend the word element corresponding to vector Vc (or "0" by 5 bits immediately The word integer formed by the number #c) is written to the corresponding position of Vd.
 op: |
  for (i = 0; i <8; i ++) {
    vc [i] = va [i] == 0? vb [i]: vc [i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vsellew
 header: simd.h
 inst: vsellew
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va <= 0? vb: vc
 desc: |
  Perform a comparison test of less than or equal to each word element in Va and 0. If the condition is true, write the word element corresponding to vector Vb to the corresponding position of Vd, otherwise extend the word element corresponding to vector Vc (or "0" by 5 bits The word integer formed by the immediate number #c) is written to the corresponding position of Vd.
 op: |
  for (i = 0; i <8; i ++) {
    vc [i] = va [i] <= 0? vb [i]: vc [i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vselltw
 header: simd.h
 inst: vselltw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   va <0? vb: vc
 desc: |
  Perform a less than comparison test on each word element in Va with 0. If the condition is true, write the word element corresponding to vector Vb to the corresponding position of Vd, otherwise extend the word element corresponding to vector Vc (or "0" by 5 bits immediately The word integer formed by the number #c) is written to the corresponding position of Vd.
 op: |
  for (i = 0; i <8; i ++) {
    vc [i] = va [i] <= 0? vb [i]: vc [i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]

-
 name: simd_vsellbcw
 header: simd.h
 inst: vsellbcw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: |
   (va & 1) == 0? vb: vc
 desc: |
  Test the low bit of each word element in Va, if it is 0, write the word element corresponding to vector Vb to the corresponding position of Vd, otherwise write the word element corresponding to vector Vc (or "0" by 5 digits immediately # c word integer) written to the corresponding position of Vd.
 op: |
  for (i = 0; i <8; i ++) {
    vc [i] = (va [i] & 1) == 0? vb [i]: vc [i];
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-arith, SIMD-int]
-
 name: simd_vlog
 header: simd.h
 inst: vlogzz
 params:
 -
  int zz: truth table, need to be immediate
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: zz [(va << 2) + (vb << 1) + vc]
 desc: |
  Each bit corresponding to Va, Vb, and Vc forms a 3-bit binary number, selects one bit from the 8-bit binary value of the two-digit hexadecimal parameter zz, and writes it into the corresponding bit of Vd.
 op: |
  int truth [8];
  for (i = 0; i <8; i ++)
    truth [i] = (zz >> i) & 1;
  for (i = 0; i <8; i ++) {
    vc [i] = 0;
    for (j = 0; j <32; j ++) {
      a = (va [i] >> j) & 1;
      b = (vb [i] >> j) & 1;
      c = (vc [i] >> j) & 1;
      vc [i] = truth [(a << 2) + (b << 1) + c];
    }
  }
  return vc;
 tags: [MPE]
 cates: [SIMD, SIMD-logical, SIMD-int]
-
 name: simd_vaddd
 inst: vaddd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va + vb
 desc: |
  The doublev4 type addition operation adds 4 double floating point numbers in va to 4 double floating point numbers in vb respectively. Can be replaced with "+" symbol.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] + vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vadds
 inst: vadds
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va + vb
 desc: |
  The addition operation of floatv4 type adds 4 float floating point numbers in va and 4 float floating point numbers in vb respectively. Can be replaced with "+" symbol.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] + vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsubd
 inst: vsubd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va-vb
 desc: |
  Doublev4 type of subtraction operation, the 4 double floating point numbers in va and 4 double floating point numbers in vb respectively. Can be replaced with "-" symbol.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i]-vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsubs
 inst: vsubs
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va-vb
 desc: |
  Subtraction operation of floatv4 type, the 4 float floating-point numbers in va and 4 float floating-point numbers in vb are subtracted. Can be replaced with "-" symbol.
 op: |
  for (i = 0; i <4; i ++)
   vc [i] = va [i]-vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmuld
 inst: vmuld
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va * vb
 desc: |
  Doublev4 type multiplication operation, multiplying 4 double floating point numbers in va and 4 double floating point numbers in vb respectively. Can be replaced with "*" symbol.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] * vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmuls
 inst: vmuls
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va * vb
 desc: |
  The floatv4 type multiplication operation multiplies the 4 float floating-point numbers in va with the 4 float floating-point numbers in vb Can be replaced with "*" symbol.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] * vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmad
 inst: vmad
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: va * vb + vc
 desc: |
  The doublev4 type multiply-add operation multiplies the 4 double floating point numbers in va, 4 double floating point numbers in vb, and 4 floating point numbers in vc. Can be replaced with "*" and "+" symbols.
  ret = va * vb + vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] * vb [i] + vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmas
 inst: vmas
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4:
 desc: |
  The floatv4 type multiply-add operation multiplies the 4 float floating-point numbers in va, 4 float floating-point numbers in vb and 4 floating-point numbers in vc respectively Can be replaced with "*" and "+" symbols.
  ret = va * vb + vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] * vb [i] + vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vmsd
 inst: vfmsd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: va * vb-vc
 desc: |
  Doublev4 type multiplication and subtraction operations, respectively, 4 double floating-point numbers in va, 4 double floating-point numbers in vb and 4 floating-point numbers in vc, respectively Can be replaced with "*" and "-" symbols.
  ret = va * vb-vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] * vb [i]-vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vmss
 inst: vmss
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: va * vb-vc
 desc: |
  The floatv4 type of multiplication and subtraction operations respectively multiplies and subtracts 4 floating point numbers in va, 4 floating point numbers in vb and 4 floating point numbers in vc. Can be replaced with "*" and "-" symbols.
  ret = va * vb-vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] * vb [i]-vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vnmad
 inst: vnmad
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: -va * vb + vc
 desc: |
  Negative multiply-add operations of type doublev4, perform 4 multiply-add operations on 4 double floating point numbers in va, 4 double floating point numbers in vb, and 4 floating point numbers in vc Can be replaced with "*" and "+" and "-" symbols.
  ret = -va * vb + vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = -va [i] * vb [i] + vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vnmas
 inst: vnmas
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: -va * vb + vc
 desc: |
  Negative multiply-add operations of type floatv4, perform 4 multiply-add operations on 4 float floating-point numbers in va, 4 float floating-point numbers in vb and 4 floating-point numbers in vc Can be replaced with "*" and "+" and "-" symbols.
  ret = -va * vb + vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = -va [i] * vb [i] + vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vnmsd
 inst: vnmsd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: -va * vb-vc
 desc: |
  Negative multiplication and subtraction of doublev4 type, the 4 double floating-point numbers in va, 4 double floating-point numbers in vb and 4 floating-point numbers in vc are negative multiplication and subtraction operations respectively. Can be replaced with "*" and "+" and "-" symbols.
  ret = -va * vb-vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = -va [i] * vb [i]-vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vnmss
 inst: vnmss
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4:
 desc: |
  Negative multiplication and subtraction of floatv4 type, the four float floating-point numbers in va and 4 float floating-point numbers in vb and 4 floating-point numbers in vc are respectively subjected to negative multiplication and subtraction. Can be replaced with "*" and "+" and "-" symbols.
  ret = -va * vb-vc;
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = -va [i] * vb [i]-vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vseleq
 inst: vseleq
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va == 0? vb: vc
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is equal to 0, return the value of vb; otherwise, return the value of vc.
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] == 0? vb [i]: vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vseleq
 inst: vseleq
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va == 0? vb: vc
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is equal to 0, return the value of vb; otherwise, return the value of vc.
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] == 0? vb [i]: vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsellt
 inst: vsellt
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va <0? vb: vc
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is less than 0, return the value of vb; otherwise, return the value of vc.
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] <0? vb [i]: vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsellt
 inst: vsellt
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va <0? vb: vc
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is less than 0, return the value of vb; otherwise, return the value of vc.
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] <0? vb [i]: vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vselle
 inst: vselle
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  doublev4 vc:
 -
  return doublev4: |
   va <= 0? vb: vc
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] <= 0? vb [i]: vc [i];
  return vd;
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is less than or equal to 0, return the value of vb; otherwise, return the value of vc.
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vselle
 inst: vselle
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  floatv4 vc:
 -
  return floatv4: |
   va <= 0? vb: vc
 desc: |
  Determine the parameter va of type doublev4 / floatv4. If it is less than or equal to 0, return the value of vb; otherwise, return the value of vc.
 op: |
  for (i = 0; i <4; i ++)
    vd [i] = va [i] <= 0? vb [i]: vc [i];
  return vd;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpys
 inst: vcpys
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   (va & 8000 0000) | (vb & 0x7fff ffff)
 desc: |
  Floating point copy symbol, the sign bit in the return value is the sign bit of va, and the rest is the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = (va [i] & 80000000) | (vb [i] & 0x7fffffff);
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpys
 inst: vcpys
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   (va & 8000 0000 0000 0000) | (vb & 0x7fff ffff ffff ffff)
 desc: |
  Floating point copy symbol, the sign bit in the return value is the sign bit of va, and the rest is the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = (va [i] & 8000000000000000LL) | (vb [i] & 0x7fffffffffffffffLLLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vcpyse
 inst: vcpyse
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: (va & 0xff80 0000) | (vb & 0x007f ffff)
 desc: |
  Floating point copies the sign and exponent, the sign and exponent bits in the return value are the data of va, and the rest are the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = (va [i] & 0xff800000) | (vb [i] & 0x007fffff);
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpyse
 inst: vcpyse
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   (va & 0xfff0 0000 0000 0000) | (vb & 0x000f ffff ffff ffff)
 desc: |
  Floating point copies the sign and exponent, the sign and exponent bits in the return value are the data of va, and the rest are the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = (va [i] & 0xfff0000000000000LL) | (vb [i] & 0x000fffffffffffffLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vcpysn
 inst: vcpysn
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   ((~ va) & 0x8000 0000) | (vb & 0x7fff ffff)
 desc: |
  Floating point copy inverse sign, the sign bit in the return value is the inverse sign of the sign bit of va, and the rest is the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = ((~ va) & 0x80000000) | (vb & 0x7fffffff)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vcpysn
 inst: vcpysn
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   ((~ va) & 0x8000 0000 0000 0000) | (vb & 0x7fff ffff ffff ffff)
 desc: |
  Floating point copy inverse sign, the sign bit in the return value is the inverse sign of the sign bit of va, and the rest is the data in vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = ((~ va [i]) & 0x8000000000000000LL) | (vb [i] & 0x7fffffffffffffffLL)
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vdivd
 inst: vdivd
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: va / vb
 desc: |
  The doublev4 type division operation divides 4 double floating point numbers in va and 4 double floating point numbers in vb respectively.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] / vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vdivs
 inst: vdivs
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: va / vb
 desc: |
  The floatv4 type multiplication operation divides the four float floating-point numbers in va and the four float floating-point numbers in vb respectively.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] / vb [i];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vsqrtd
 inst: vsqrtd
 params:
 -
  doublev4 va:
 -
  return doublev4: sqrt (va)
 desc: |
  The square root operation of doublev4 type is to square the four double floating point numbers in va.
 op: |
  for (i = 0; i <4; i ++)
    vb [i] = sqrt (va [i]);
  return vb;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vsqrts
 inst: vsqrts
 params:
 -
  floatv4 va:
 -
  return floatv4: sqrt (va)
 desc: |
  The square root operation of floatv4 type is to square the four floating-point numbers in va.
 op: |
  for (i = 0; i <4; i ++)
    vb [i] = sqrt (va [i]);
  return vb;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]

-
 name: simd_vfcmpeq
 inst: vfcmpeq
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va == vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb for equality, if the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc .
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] == vb [i]? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmpeq
 inst: vfcmpeq
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va == vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb for equality, if the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc .
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] == vb [i]? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmple
 inst: vfcmple
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va <= vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb with less than or equal to each other. If the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc position.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] <= vb [i]? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmple
 inst: vfcmple
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va <= vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb with less than or equal to each other. If the condition holds, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc position.
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmplt
 inst: vfcmplt
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   va <vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb to less than the comparison. If the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc .
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] <vb [i]? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmplt
 inst: vfcmplt
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   va <vb? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb to less than the comparison. If the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc .
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = va [i] <vb [i]? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vfcmpun
 inst: vfcmpun
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   isnan (va) || isnan (vb)? 2.0: 0
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb out of order. If the condition holds, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc position.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = isnan (va [i]) || isnan (vb [i])? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-dp]
-
 name: simd_vfcmpun
 inst: vfcmpun
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   isnan (va) || isnan (vb)? 2.0: 0;
 desc: |
  Compare the corresponding floating-point vector elements in Va and Vb out of order. If the condition is true, write a non- "0" floating-point value (2.0) to the corresponding position of vc, otherwise write a true "0" to the corresponding position of vc position.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = isnan (va [i]) || isnan (vb [i])? 2.0: 0;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-arith, SIMD-sp]
-
 name: simd_vinswn
 inst: vinsw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: |
   vb [0: n] va [0] vb [n + 1: 8]
 desc: |
  Convert the lower 64-bit register format word integer of the floating-point register va to a 32-bit word integer, replace the 32-bit word element specified by n (valid value is 0 to 7) in vb, and form a new word integer vector.
  This interface actually corresponds to 8 interfaces, namely simd_vinsw0, simd_vinsw1, simd_vinsw2, simd_vinsw3, simd_vinsw4, simd_vinsw5, simd_vinsw6, simd_vinsw7, for example:
  vc = simd_vinsw2
  The low 64-bit register format word integer representing va is first converted to a 32-bit word integer, and then the 32-bit word elements of 64:95 of vb are replaced, and a new vb is formed and returned to vc.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = vb [i];
  vc [n] = va [n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vinsfn
 inst: vinsf
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  return doublev4: |
   vb [0: n] va [0] vb [n + 1: 8]
 desc: |
  Replace the 64-bit floating-point data in the floating-point register va with low 64-bit floating-point data specified by n (valid values ​​are 0 to 3) in vb to form and return a new floating-point vector.
  This interface actually corresponds to 4 interfaces, namely simd_vinsf0, simd_vinsf1, simd_vinsf2, simd_vinsf3, for example:
  vc = simd_vinsf1 (va, vb)
  It means that 64-bit floating-point data of low 64-bit floating-point data of va replaces 64-bit floating-point elements of 64: 127, and a new vb is returned to vc.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = vb [i];
  vc [n] = va [n];

 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vinsfn
 inst: vinsf
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  return floatv4: |
   vb [0: n] va [0] vb [n + 1: 8]
 desc: |
  Replace the 64-bit floating-point data in the floating-point register va with low 64-bit floating-point data specified by n (valid values ​​are 0 to 3) in vb to form and return a new floating-point vector.
  This interface actually corresponds to 4 interfaces, namely simd_vinsf0, simd_vinsf1, simd_vinsf2, simd_vinsf3, for example:
  vc = simd_vinsf1 (va, vb)
  It means that 64-bit floating-point data of low 64-bit floating-point data of va replaces 64-bit floating-point elements of 64: 127, and a new vb is returned to vc.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = vb [i];
  vc [n] = va [n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_vextwn
 inst: vextw
 params:
 -
  intv8 va:
 -
  return intv8: va [n]
 desc: |
  Write the 32-bit word element specified by n (valid value is 0 to 7) in va into a 64-bit register format word integer into the lower 64 bits of the destination floating-point register, and the contents of the upper 192 bits of the destination register are undefined.
  This interface actually corresponds to 8 interfaces, namely simd_vextw0, simd_vextw1, simd_vextw2, simd_vextw3, simd_vextw4, simd_vextw5, simd_vextw6, simd_vextw7, such as:
  vc = simd_vextw2 (va)
  The 32-bit word element representing 64:95 of va, and the word integer converted into the 64-bit register format are written to the lower 64 bits of vc, of which the upper 192 bits of vc are uncertain.
 op: return va [n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int]
-
 name: simd_vextfn
 inst: vextf
 params:
 -
  doublev4 va:
 -
  return doublev4: va [n]
 desc: |
  Store the S floating point or D floating point element specified by n (valid value is 0 to 3) in va in <63: 0> of the destination register. This instruction can extract S floating point and D floating point.
  This interface actually corresponds to 4 interfaces, namely simd_vextf0, simd_vextf1, simd_vextf2, simd_vextf3, for example:
  vc = simd_vextf1 (va)
  The 64-bit floating point element representing 64: 127 of va is stored in <63: 0> of vc.
 op: return va [n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vextfn
 inst: vextf
 params:
 -
  floatv4 va:
 -
  return floatv4: va [n]
 desc: |
  Store the S floating point or D floating point element specified by n (valid value is 0 to 3) in va in <63: 0> of the destination register. This instruction can extract S floating point and D floating point.
  This interface actually corresponds to 4 interfaces, namely simd_vextf0, simd_vextf1, simd_vextf2, simd_vextf3, for example:
  vc = simd_vextf1 (va)
  The 64-bit floating point element representing 64: 127 of va is stored in <63: 0> of vc.
 op: return va [n];
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_vcpyw
 inst: vcpyw
 params:
 -
  doublev4 va:
 -
  return intv8: |
   * (int *) & va [0];
 desc: |
  Convert the low 64-bit register format word integer of va into a 32-bit word integer, copy into 8 identical elements to form a new word integer vector and write it into the destination register.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = * (int *) & va [0] ;;
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int, SIMD-sp]
-
 name: simd_vcpyw
 inst: vcpyw
 params:
 -
  floatv4 va:
 -
  return intv8: |
   * (int *) & va [0];
 desc: |
  Convert the low 64-bit register format word integer of va into a 32-bit word integer, copy into 8 identical elements to form a new word integer vector and write it into the destination register.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = * (int *) & va [0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-int, SIMD-sp]
-
 name: simd_vcpyf
 inst: vcpyf
 params:
 -
  doublev4 va:
 -
  return doublev4: va [0]
 desc: |
  Copy the low 64-bit floating-point data of va into 4 identical elements and form a new floating-point vector into the destination register.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = va [0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-dp]
-
 name: simd_vcpyf
 inst: vcpyf
 params:
 -
  floatv4 va:
 -
  return floatv4: va [0]
 desc: |
  Copy the low 64-bit floating-point data of va into 4 identical elements and form a new floating-point vector into the destination register.
 op: |
  for (i = 0; i <8; i ++)
    vc [i] = va [0];
  return vc;
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-misc, SIMD-sp]
-
 name: simd_set_doublev4
 params:
 -
  double a:
 -
  double b:
 -
  double c:
 -
  double d:
 -
  return doublev4: |
   [a, b, c, d]
 desc: |
  The assignment function of type doublev4 transfers four data of type double to vector variables.
 eg: |
  doublev4 va = simd_set_doublev4 (1.0, 2.0, 3.0, 4.0);
  The value in va is this:
    + ----- + ----- + ----- + ----- +
    | 4.0 | 3.0 | 2.0 | 1.0 |
    + ----- + ----- + ----- + ----- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-dp]
-
 name: simd_set_floatv4
 params:
 -
  float a:
 -
  float b:
 -
  float c:
 -
  float d:
 -
  return floatv4: |
   [a, b, c, d]
 desc: |
  The assignment function of type floatv4 transfers 4 data of type float to a vector variable.
 eg: |
  floatv4 va = simd_set_floatv4 (1.0, 2.0, 3.0, 4.0);
  The value in va is this:
    + ----- + ----- + ----- + ----- +
    | 4.0 | 3.0 | 2.0 | 1.0 |
    + ----- + ----- + ----- + ----- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-sp]
-
 name: simd_set_intv8
 params:
 -
  int a:
 -
  int b:
 -
  int c:
 -
  int d:
 -
  int e:
 -
  int f:
 -
  int g:
 -
  int h:
 -
  return intv8: |
   [a, b, c, d, e, f, g, h]
 desc: |
  The intv8 type assignment function passes 8 int types of data to a vector variable.
 eg: |
  va = simd_set_intv8 (1,2,3,4,5,6,7,8);
  The value in va is this:
    + --- + --- + --- + --- + --- + --- + --- + --- +
    8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
    + --- + --- + --- + --- + --- + --- + --- + --- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_uintv8
 params:
 -
  unsigned int a:
 -
  unsigned int b:
 -
  unsigned int c:
 -
  unsigned int d:
 -
  unsigned int e:
 -
  unsigned int f:
 -
  unsigned int g:
 -
  unsigned int h:
 -
  return uintv8: |
   [a, b, c, d, e, f, g, h]
 desc: |
  The uintv8 type assignment function transfers 8 unsigned int types of data to vector variables.
 eg: |
  va = simd_set_uintv8 (1,2,3,4,5,6,7,8);
  The value in va is this:
    + --- + --- + --- + --- + --- + --- + --- + --- +
    8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 |
    + --- + --- + --- + --- + --- + --- + --- + --- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_int256
 params:
 -
  long a:
 -
  long b:
 -
  long c:
 -
  long d:
 -
  return int256: |
   [a, b, c, d]
 desc: |
  The assignment function of type int256 transfers 4 long types of data to a vector variable.
 eg: |
  va = simd_set_int256 (1,2,3,4);
  The value in va is this:
    + --- + --- + --- + --- +
    | 4 | 3 | 2 | 1 |
    + --- + --- + --- + --- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_set_uint256
 params:
 -
  unsigned long a:
 -
  unsigned long b:
 -
  unsigned long c:
 -
  unsigned long d:
 -
  return uint256: |
   [a, b, c, d]
 desc: |
  An assignment function of type uint256 transfers 4 unsigned long types of data to a vector variable.
 eg: |
  va = simd_set_uint256 (1,2,3,4);
  The value in va is this:
    + --- + --- + --- + --- +
    | 4 | 3 | 2 | 1 |
    + --- + --- + --- + --- +
  255 0
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-set, SIMD-int]
-
 name: simd_fprint_intv8
 params:
 -
  FILE * file:
 -
  intv8 va:
 desc: |
  The data of type intv8 is printed in the file file in the form of 8 ints.
 eg: |
  va = simd_set_intv8 (1,2,3,4,5,6,7,8);
  simd_fprint_intv8 (stderr, va);
  The printed result is this:
  [8, 7, 6, 5, 4, 3, 2, 1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-int]
-
 name: simd_fprint_uintv8
 params:
 -
  FILE * file:
 -
  uintv8 va:
 desc: |
  The uintv8 type data is printed to the file file in the form of 8 ints.
 eg: |
  va = simd_set_uintv8 (1,2,3,4,5,6,7,8);
  simd_fprint_uintv8 (stderr, va);
  The printed result is this:
  [8, 7, 6, 5, 4, 3, 2, 1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_int256
 params:
 -
  FILE * file:
 -
  int256 va:
 desc: |
  Data of type int256 is printed in the file file in the form of 4 longs.
 eg: |
  va = simd_set_int256 (1,2,3,4);
  simd_fprint_int256 (stderr, va);
  The printed result is this:
  [0x4, 0x3, 0x2, 0x1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_uint256
 params:
 -
  FILE * file:
 -
  uint256 va:
 desc: |
  The uint256 type data is printed in the file file in the form of 4 longs.
 eg: |
  va = simd_set_uint256 (1,2,3,4);
  simd_fprint_uint256 (stderr, va);
  The printed result is this:
  [0x4, 0x3, 0x2, 0x1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_fprint_floatv4
 params:
 -
  FILE * file:
 -
  floatv4 va:
 desc: |
  Data of type floatv4 is printed in the file file in the form of 4 floats.
 eg: |
  va = simd_set_floatv4 (1.0,2.0,3.0,4.0);
  simd_fprint_floatv4 (stderr, va);
  The printed result is this:
  [3.0, 4.0, 2.0, 1.0]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-sp]
-
 name: simd_fprint_doublev4
 params:
 -
  FILE * file:
 -
  doublev4 va:
 desc: |
  Data of type doublev4 is printed in the file file in the form of 4 doubles.
 eg: |
  va = simd_set_doublev4 (1.0,2.0,3.0,4.0);
  simd_fprint_doublev4 (stderr, va);
  The printed result is this:
  [4.0, 3.0, 2.0, 1.0]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_intv8
 params:
 -
  intv8 va:
 desc: |
  The intv8 type data is printed to the screen in the form of 8 ints.
 eg: |
  va = simd_set_intv8 (1,2,3,4,5,6,7,8);
  simd_print_intv8 (va);
  The printed result is this:
  [8, 7, 6, 5, 4, 3, 2, 1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_uintv8
 params:
 -
  uintv8 va:
 desc: |
  Data of type uintv8 is printed to the screen in the form of 8 ints.
 eg: |
  va = simd_set_uintv8 (1,2,3,4,5,6,7,8);
  simd_print_uintv8 (va);
  The printed result is this:
  [8, 7, 6, 5, 4, 3, 2, 1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_int256
 params:
 -
  int256 va:
 desc: |
  Data of type int256 is printed to the screen in the form of 4 longs.
 eg: |
  va = simd_set_int256 (1,2,3,4);
  simd_print_int256 (va);
  The printed result is this:
  [0x4, 0x3, 0x2, 0x1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_uint256
 params:
 -
  uint256 va:
 desc: |
  Data of type uint256 is printed to the screen in the form of 4 longs.
 eg: |
  va = simd_set_uint256 (1,2,3,4);
  simd_print_uint256 (va);
  The printed result is this:
  [0x4, 0x3, 0x2, 0x1]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_print_floatv4
 params:
 -
  floatv4 va:
 desc: |
  Data of type floatv4 is printed to the screen in the form of 4 floats.
 eg: |
  va = simd_set_floatv4 (1.0,2.0,3.0,4.0);
  simd_print_floatv4 (va);
  The printed result is this:
  [3.0, 4.0, 2.0, 1.0]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-sp]
-
 name: simd_print_doublev4
 params:
 -
  doublev4 va:
 desc: |
  Data of type doublev4 is printed to the screen in the form of 4 doubles.
 eg: |
  va = simd_set_doublev4 (1.0,2.0,3.0,4.0);
  simd_print_doublev4 (va);
  The printed result is this:
  [4.0, 3.0, 2.0, 1.0]
 header: simd.h
 tags: [MPE, CPE]
 cates: [SIMD, SIMD-print, SIMD-dp]
-
 name: simd_vlog2x
 inst: vlog2x
 params:
 -
  int n: truth table
 -
  intv8 va:
 -
  intv8 vb:
 -
  return intv8: n [(va << 1) + vb]
 desc: |
  The reconfigurable logical operations of two intv8 type operands, according to the logical truth value of n, perform logical operations on the 8 int type integer data in va and 8 int type integer data in vb.
  This feature has a compiler level bug, but it can be implemented by embedding assembly.
 eg: |
  #define simd_vlog2x_patch (r, n, a, b) asm ("vlog2x" n "idx% 2,% 1,% 0": "= r" (r): "r" (b), "r" (a ))
  simd_vlog2x_patch (r, "e", a, b) <==> vlog2xe a, b, r <==> r = a | b
 op: |
  int truth [4];
  for (i = 0; i <4; i ++)
    truth [i] = (n >> i) & 1;
  for (i = 0; i <8; i ++) {
    vc [i] = 0;
    for (j = 0; j <32; j ++) {
      a = (va [i] >> j) & 1;
      b = (vb [i] >> j) & 1;
      vc [i] = truth [(a << 1) + b];
    }
  }
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-logical, SIMD-int]
 tags: [CPE]
-
 name: simd_vlog3x
 inst: vlog3r
 params:
 -
  int n:
 -
  intv8 va:
 -
  intv8 vb:
 -
  intv8 vc:
 -
  return intv8: truth_reg [n] [(va << 2) + (vb << 1) + vc]
 desc: |
  The reconfigurable logic operation of three intv8 type operands, with the logic truth value of the n-th truth table register, perform logic operation on the 8 int type integer data in va, vb, vc.
  This feature has a compiler level bug, but it can be implemented by embedding assembly.
 eg: |
  #define vlog3r_setr (idx, truth) asm volatile ("wcsr% 1,% 0":: "i" (0x80 + idx), "r" (truth))
  #define simd_vlog3r (r, idx, a, b, c) asm ("vlog3r" idx "% 3,% 2,% 1,% 0": "= r" (r): "r" (c), " r "(b)," r "(a))
  vlog3r_setr (0x1, 0xfe) // Set the No.1 truth table register to 0xfe
  simd_vlog3r (r, "1", a, b, c) <==> r = a | b | c
 op: |
  // truth_reg is the list of truth table registers on the core
  int zz = truth_reg [n];
  int truth [8];
  for (i = 0; i <8; i ++)
    truth [i] = (zz >> i) & 1;
  for (i = 0; i <8; i ++) {
    vc [i] = 0;
    for (j = 0; j <32; j ++) {
      a = (va [i] >> j) & 1;
      b = (vb [i] >> j) & 1;
      c = (vc [i] >> j) & 1;
      vc [i] = truth [(a << 2) + (b << 1) + c];
    }
  }
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-logical, SIMD-int]
 tags: [CPE]
-
 name: simd_uaddo_carry
 inst: uaddo_carry
 params:
 -
  uint256 va:
 -
  uint256 vb:
 -
  return uint256: va + vb
 desc: |
  Unsigned 256-bit integer Va and Vb (or 8-bit unsigned immediate #b) are added, and the lower 256 bits of the sum are sent to the return value. If a carry occurs, the CA performs an increment operation.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = 0;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i] + (long) (unsigned int) vb [i] + CC;
    if (tmp> MAX_UINT)
      CC = 1;
    vc [i] = tmp;
  }
  CA + = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_usubo_carry
 inst: usubo_carry
 params:
 -
  uint256 va:
 -
  uint256 vb:
 -
  return uint256: va-vb
 desc: |
  The unsigned 256-bit integer Va and Vb (or 8-bit unsigned immediate #b) are subtracted, and the lower 256 bits of the difference are sent to Vc. If a borrow occurs, the CA performs a minus 1 operation.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = 0;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i]-(long) (unsigned int) vb [i] + CC;
    if (tmp <0)
      CC = -1;
    vc [i] = tmp;
  }
  CA + = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_uaddo_take_carry
 inst: uaddo_take_carry
 params:
 -
  uint256 va:
 -
  uint256 vb:
 -
  return uint256: va + vb
 desc: |
  Unsigned 256-bit integers Va and Vb (or 8-bit unsigned immediate #b) are added, and then the signed number stored in CA is added, and the lower 256 bits of the result are sent to Vc. If a carry occurs, CA is set to the carry value (may be +1 or +2); if a borrow occurs, CA is set to -1; otherwise, CA is cleared to 0.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = CA;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i] + (long) (unsigned int) vb [i] + CC;
    if (tmp> MAX_UINT)
      CC = 1;
    vc [i] = tmp;
  }
  CA = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_usubo_take_carry
 inst: usubo_take_carry
 params:
 -
  uint256 va:
 -
  uint256 vb:
 -
  return uint256: va-vb
 desc: |
  Unsigned 256-bit integers Va and Vb (or 8-bit unsigned immediate #b) are subtracted, and then the signed number stored in CA is added, and the lower 256 bits of the result are sent to Vc. If a carry occurs, CA is set to +1; if a borrow occurs, CA is set to the borrow value (may be -1 or -2); otherwise, CA is cleared to 0.
 op: |
  // CA is the carry register
  int CC = CA;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i]-(long) (unsigned int) vb [i] + CC;
    if (tmp <0)
      CC = -1;
    vc [i] = tmp;
  }
  CA = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_addo_carry
 inst: addo_carry
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va + vb
 desc: |
  The signed 256-bit integer Va and Vb (or 8-bit unsigned immediate #b) are added, and the lower 256 bits of the sum are sent to Vc. If a carry occurs, CA performs an increment operation; if a borrow occurs, CA performs a decrement operation. When borrowing occurs, the adjustment result is a legal signed 256-bit integer between -2 ^ 255 and + 2 ^ 255-1.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = 0;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i] + (long) (unsigned int) vb [i] + CC;
    if (tmp> MAX_UINT)
      CC = 1;
    vc [i] = tmp;
  }
  CA + = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_subo_carry
 inst: subo_carry
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va-vb
 desc: |
  The signed 256-bit integer Va and Vb (or 8-bit unsigned immediate #b) are subtracted, and the lower 256 bits of the difference are sent to Vc. If a carry occurs, CA performs an increment operation; if a borrow occurs, CA performs a decrement operation. When borrowing occurs, the adjustment result is a legal signed 256-bit integer between -2 ^ 255 and + 2 ^ 255-1.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = 0;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i]-(long) (unsigned int) vb [i] + CC;
    if (tmp <0)
      CC = -1;
    vc [i] = tmp;
  }
  CA + = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_addo_take_carry
 inst: addo_take_carry
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va + vb
 desc: |
  The signed 256-bit integers Va and Vb (or 8-bit unsigned immediate #b) are added to CA, and the lower 256 bits of the result are sent to Vc. If a carry occurs, CA is set to the carry value (may be +1 or +2); if a borrow occurs, CA is set to the borrow value (may be -1 or -2); otherwise, CA is cleared to 0. When borrowing occurs, the adjustment result is a legal signed 256-bit integer between -2 ^ 255 and + 2 ^ 255-1.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = CA;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i] + (long) (unsigned int) vb [i] + CC;
    if (tmp> MAX_UINT)
      CC = 1;
    vc [i] = tmp;
  }
  CA = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_subo_take_carry
 inst: subo_take_carry
 params:
 -
  int256 va:
 -
  int256 vb:
 -
  return int256: va + vb
 desc: |
  The signed 256-bit integer Va and Vb (or 8-bit unsigned immediate #b) are subtracted, and then the signed number stored in CA is added, and the lower 256 bits of the result are sent to Vc. If a carry occurs, CA is set to the carry value (may be +1 or +2); if a borrow occurs, CA is set to the borrow value (may be -1 or -2); otherwise CA is cleared to 0. When borrowing occurs, the adjustment result is a legal signed 256-bit integer between -2 ^ 255 and + 2 ^ 255-1.
  CA is an internal 8-bit signed register that can represent an integer between -128 and +127, with an initial value of 0. CA overflow causes a "borrow borrow overflow" exception.
 op: |
  // CA is the carry register
  int CC = CA;
  for (i = 0; i <8; i ++) {
    long tmp = (long) (unsigned int) va [i] + (long) (unsigned int) vb [i] + CC;
    if (tmp> MAX_UINT)
      CC = 1;
    vc [i] = tmp;
  }
  CA = CC;
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_umulqa
 inst: umulqa
 params:
 -
  uint256 va:
 -
  uint256 vb:
 -
  return uint256: va * vb
 desc: |
  The lower 128 bits of the vector register Va and the lower 128 bits of Vb (or 8-bit unsigned immediate #b) are multiplied as unsigned integers, and the resulting 256-bit unsigned result is written to the target register Vc. The upper 128 bits of Va and Vb are ignored.
 op: |
  long prod [8];
  for (i = 0; i <8; i ++)
    prod [i] = 0;
  for (i = 0; i <4; i ++)
    for (j = 0; j <4; j ++)
      prod [i + j] + = (long) (unsigned int) va [i] * (long) (unsigned int) vb [i];
  for (i = 0; i <8; i ++) {
    prod [i + 1] + = prod [i] / (MAX_UINT + 1);
    prod [i]% = (MAX_UINT + 1);
  }
  return (uint256) simd_set_intv8 (prod [0], prod [1], prod [2], prod [3]
                               , prod [4], prod [5], prod [6], prod [7]);
 header: "simd.h"
 cates: [SIMD, SIMD-arith, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_vshff
 inst: vshfw
 params:
 -
  intv8 va:
 -
  intv8 vb:
 -
  int Rc:
 -
  return intv8:
 desc: |
  The eight 32-bit numbers of the returned value are filled by Va and Vb. Va is responsible for filling 4 high 32bits, and Vb is responsible for filling 4 low 32bits. The specific how to fill is explained by Rc:
  Rc's <30:28> points out that vd's <255: 224> is from Va's location
  Rc's <26:24> pointed out that vd's <223: 192> came from Va's location
  Rc's <22:20> pointed out that vd's <191: 160> came from Va's location
  Rc's <18:16> points out that vd's <159: 128> is from Va's location
  Rc's <14:12> points out that vd's <127: 96> comes from the position of Vb
  Rc's <10: 8> points out that vd's <95:64> comes from the location of Vb
  Rc's <6: 4> points out that vd's <63:32> comes from the position of Vb
  Rc's <2: 0> points out that vd's <31: 0> comes from Vb's position
  The position of Va / Vb (0 ~ 7) means that Va / Vb is divided into 8 32bits of natural boundaries, and the position of 0 means 0th 32bit ([31: 0]), and so on.
 eg: |
  intv8 va, vb, vd;
  int rc = 0x12345670;
  vd = vshuffle (va, vb, rc).
  The meaning is from high to low, the 8 32bits of vd are derived from:
  0x1: the first 32bit of va;
  0x2: the second 32bit of va;
  0x3: the third 32bit of va;
  0x4: the fourth 32bit of va;
  0x5: the fifth 32bit of vb;
  0x6: the sixth 32bit of vb;
  0x7: the seventh 32bit of vb;
  0x0: 0th 32bit of vb.
 op: |
  for (i = 0; i <4; i ++)
    vc [i] = vb [(rc >> (i * 4))];
  for (i = 4; i <8; i ++)
    vc [i] = va [(rc >> (i * 4))];
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-misc, SIMD-int]
 tags: [CPE]
-
 name: simd_vshff
 inst: vshfw
 params:
 -
  doublev4 va:
 -
  doublev4 vb:
 -
  int Rc:
 -
  return doublev4:
 desc: |
  The four 64-bit numbers of the return value are filled by Va and Vb. Va is responsible for filling the two high 64bits of Vd, and Vb is responsible for the two low 64bits of Vd. How to fill is explained by Rc / # c:
  Rc / # c's <7: 6> points out that vd's <255: 192> is from Va's location
  Rc / # c's <5: 4> points out that vd's <191: 128> is from Va's location
  Rc / # c's <3: 2> points out that vd's <127: 64> comes from the location of Vb
  Rc / # c's <1: 0> points out that vd's <63: 0> comes from the position of Vb
  The position of Va / Vb (0 ~ 3) means that Va / Vb is divided into 4 64bits with natural boundaries, and the position 0 means the 0th 64bit ([63: 0]), and so on.
  Example: Take the immediate operand as an example
  doublev4 va, vb, vd;
  vd = simd_shuffle (va, vb, 8’b01111000)
  The meaning is from high to low. The four 64bits of vd are derived from the first 64bits of va, the third 64bits of va, the second 64bits of vb, and the zeroth 64bits of vb.
 op: |
  for (i = 0; i <2; i ++)
    vc [i] = vb [(rc >> (i * 2))];
  for (i = 2; i <4; i ++)
    vc [i] = va [(rc >> (i * 2))];
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-misc, SIMD-dp]
 tags: [CPE]
-
 name: simd_vshff
 inst: vshfw
 params:
 -
  floatv4 va:
 -
  floatv4 vb:
 -
  int rc:
 -
  return floatv4:
 desc: |
  The four 64-bit numbers of the return value are filled by Va and Vb. Va is responsible for filling the two high 64bits of Vd, and Vb is responsible for the two low 64bits of Vd. How to fill is explained by Rc / # c
  Rc / # c's <7: 6> points out that vd's <255: 192> is from Va's location
  Rc / # c's <5: 4> points out that vd's <191: 128> is from Va's location
  Rc / # c's <3: 2> points out that vd's <127: 64> comes from the location of Vb
  Rc / # c's <1: 0> points out that vd's <63: 0> comes from the position of Vb
  The position of Va / Vb (0 ~ 3) means that Va / Vb is divided into 4 64bits with natural boundaries, and the position 0 means the 0th 64bit ([63: 0]), and so on.
  Example: Take the immediate operand as an example
  doublev4 va, vb, vd;
  vd = simd_shuffle (va, vb, 8’b01111000)
  The meaning is from high to low. The four 64bits of vd are derived from the first 64bits of va, the third 64bits of va, the second 64bits of vb, and the zeroth 64bits of vb.
 op: |
  for (i = 0; i <2; i ++)
    vc [i] = vb [(rc >> (i * 2))];
  for (i = 2; i <4; i ++)
    vc [i] = va [(rc >> (i * 2))];
  return vc;
 header: "simd.h"
 cates: [SIMD, SIMD-misc, SIMD-sp]
 tags: [CPE]
-
 name: simd_loadr
 inst: vldr
 params:
 -
  intv8 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32 bytes of data from a continuous memory area into a vector variable, and broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_loadr
 inst: vldr
 params:
 -
  int256 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32 bytes of data from a continuous memory area into a vector variable, and broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_loadr
 inst: vldr
 params:
 -
  doublev4 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32 bytes of data from a continuous memory area into a vector variable, and broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_loadc
 inst: vldc
 params:
 -
  intv8 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32-byte data from a continuous memory area into a vector variable, and perform column broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_loadc
 inst: vldc
 params:
 -
  int256 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32-byte data from a continuous memory area into a vector variable, and perform column broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_loadc
 inst: vldc
 params:
 -
  doublev4 va: load result
 -
  void * addr: memory address
 desc: |
  Extended type loading, load 32-byte data from a continuous memory area into a vector variable, and perform column broadcast.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_loader
 inst: ldder
 params:
 -
  intv8 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64-bit) from memory, and simultaneously write to the position of the four double-precision floating-point vector elements in the vector register Va, and broadcast it line by line.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_loader
 inst: ldder
 params:
 -
  int256 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64-bit) from memory, and simultaneously write to the position of the four double-precision floating-point vector elements in the vector register Va, and broadcast it line by line.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_loader
 inst: ldder
 params:
 -
  doublev4 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64-bit) from memory, and simultaneously write to the position of the four double-precision floating-point vector elements in the vector register Va, and broadcast it line by line.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_loadec
 inst: lddec
 params:
 -
  intv8 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64 bits) from memory, and simultaneously write to the position of four double-precision floating-point vector elements in the vector register Va, and perform column-wise broadcasting.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_loadec
 inst: lddec
 params:
 -
  int256 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64 bits) from memory, and simultaneously write to the position of four double-precision floating-point vector elements in the vector register Va, and perform column-wise broadcasting.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-octa-word]
 tags: [CPE]
-
 name: simd_loadec
 inst: lddec
 params:
 -
  doublev4 va: load result
 -
  void * addr: memory address
 desc: |
  Load and expand the extension type. Load a double-precision floating-point or long word (64 bits) from memory, and simultaneously write to the position of four double-precision floating-point vector elements in the vector register Va, and perform column-wise broadcasting.
 header: "simd.h"
 cates: [SIMD, SIMD-load, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_getr
 inst: getr
 params:
 -
  intv8 va: load result
 -
  return intv8:
 desc: |
  Read the line communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_getr
 inst: getr
 params:
 -
  int256 va: load result
 -
  return int256:
 desc: |
  Read the line communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_getr
 inst: getr
 params:
 -
  doublev4 va: load result
 -
  return doublev4:
 desc: |
  Read the line communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_getr
 inst: getr
 params:
 -
  floatv4 va: load result
 -
  return floatv4:
 desc: |
  Read the line communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-sp]
 tags: [CPE]
-
 name: simd_getc
 inst: getc
 params:
 -
  intv8 va: load result
 -
  return intv8:
 desc: |
  Read the column communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_getc
 inst: getc
 params:
 -
  int256 va: load result
 -
  return int256:
 desc: |
  Read the column communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_getc
 inst: getc
 params:
 -
  doublev4 va: load result
 -
  return doublev4:
 desc: |
  Read the column communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_getc
 inst: getc
 params:
 -
  floatv4 va: load result
 -
  return floatv4:
 desc: |
  Read the column communication buffer, read the vector in the buffer into the vector register, and clear the buffer after reading.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-sp]
 tags: [CPE]
-
 name: simd_putr
 inst: putr
 params:
 -
  intv8 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data from the core to the target on the peer, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid, of which Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation, then Rb [2: 0] (or #dest [2: 0]) is A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_putr
 inst: putr
 params:
 -
  int256 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data from the core to the target on the peer, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid, of which Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation, then Rb [2: 0] (or #dest [2: 0]) is a A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_putr
 inst: putr
 params:
 -
  doublev4 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data from the core to the target on the peer, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid, of which Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation, then Rb [2: 0] (or #dest [2: 0]) is a A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_putr
 inst: putr
 params:
 -
  floatv4 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data from the core to the target on the peer, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid, of which Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation, then Rb [2: 0] (or #dest [2: 0]) is a A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-sp]
 tags: [CPE]
-
 name: simd_putc
 inst: putc
 params:
 -
  intv8 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data to the target slave core on the same column, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid. Among them, Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation. A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_putc
 inst: putc
 params:
 -
  int256 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data to the target slave core on the same column, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid, of which Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation, then Rb [2: 0] (or #dest [2: 0]) is A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-int]
 tags: [CPE]
-
 name: simd_putc
 inst: putc
 params:
 -
  doublev4 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data to the target slave core on the same column, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid. Among them, Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation. A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-dp]
 tags: [CPE]
-
 name: simd_putc
 inst: putc
 params:
 -
  floatv4 va: vector to be sent
 -
  int dest: target slave core (8 for broadcast)
 desc: |
  Send data to the target slave core on the same column, the data width is the width of the vector register. PUT can be a point-to-point operation or a broadcast operation. When the target is at least one full during the broadcast, it pauses. The lower 4 bits of Rb are valid. Among them, Rb [3] (or #dest [3]) is the communication type bit. When it is 0, it indicates point-to-point operation. A 3-bit target bit vector indicating the target slave core number; when Rb [3] (or #dest [3]) is 1, it indicates a broadcast operation, ignoring the Rb [2: 0] bits.
 header: "simd.h"
 cates: [SIMD, SIMD-regcomm, SIMD-sp]
 tags: [CPE]
-
 name: simd_selldw
 inst: selldw
 params:
 -
  intv8 va:
 -
  intv8 Rb:
 -
  int c:
 -
  return intv8:
 desc: |
  According to #c, choose one of the eight offsets in the table pointed out by Va, and add it to the first address in Rb to get the address to access the LDM; then access the LDM and write the 32bit data to the hardware 256b buffer position. If #c is 3’b0, the result of hardware 256b buffering will be written back to Vd after the access LDM is over.
 header: "simd.h"
 cates: [SIMD, SIMD-misc, SIMD-int]
 tags: [CPE]
-
 name: simd_lookup
 inst: selldw
 params:
 -
  intv8 va:
 -
  intv8 Rb:
 -
  intv8 vc:
 -
  return intv8:
 desc: |
  Generate 8 table lookup instructions:
  simd_selldw (va, b, 7);
  simd_selldw (va, b, 6);
  simd_selldw (va, b, 5);
  simd_selldw (va, b, 4);
  simd_selldw (va, b, 3);
  simd_selldw (va, b, 2);
  simd_selldw (va, b, 1);
  vc = simd_selldw (va, b, 0);
 header: "simd.h"
 cates: [SIMD, SIMD-misc, SIMD-int]
 tags: [CPE]
